<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <script src="https://cdn.jsdelivr.net/npm/cesium@1.130/Build/Cesium/Cesium.js"></script>
    <link
      href="https://cdn.jsdelivr.net/npm/cesium@1.130/Build/Cesium/Widgets/widgets.css"
      rel="stylesheet"
    />

    <style>
      html,
      body,
      #cesiumContainer {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
      }

      /* Loading Ê†∑Âºè */
      #loading {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 5px;
        z-index: 1000;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      }

      #loading.hidden {
        display: none;
      }
    </style>
  </head>

  <body>
    <div id="cesiumContainer"></div>

    <!-- Loading ÊèêÁ§∫ -->
    <div id="loading">loading... <span id="progress">0</span>%</div>

    <script type="module">
      import * as turf from "@turf/turf";
      // Á≠âÂæÖ Cesium Âä†ËΩΩÂÆåÊàê
      function initializeApp() {
        if (typeof Cesium === "undefined") {
          setTimeout(initializeApp, 100);
          return;
        }
        initCesium();
      }

      let shader = null;
      let dynamicPrimitive = null;

      async function initCesium() {
        try {
          Cesium.Ion.defaultAccessToken =
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1OGIzZmQyZC03YjNiLTQzMjQtOWQxYS0xOTYxZWUyMTYzMjQiLCJpZCI6MzEzMjQxLCJpYXQiOjE3NTAyMjc2NDd9.G9X0WofFDt3mbp2L_WDzU__rcAVg0v3rpAliG1sgB9k";

          const terrainProvider =
            await Cesium.CesiumTerrainProvider.fromIonAssetId(1, {
              requestVertexNormals: true,
              requestWaterMask: true,
            });

          const viewer = new Cesium.Viewer("cesiumContainer", {
            //globe: false,
            terrainProvider: terrainProvider,
            scene3DOnly: true,
            baseLayerPicker: false,
            fullscreenButton: false,
            vrButton: false,
            geocoder: false,
            homeButton: false,
            infoBox: false,
            sceneModePicker: false,
            selectionIndicator: false,
            timeline: false,
            navigationHelpButton: false,
            navigationInstructionsInitiallyVisible: false,
            sceneMode: Cesium.SceneMode.SCENE3D,
          });
          viewer.scene.backgroundColor = Cesium.Color.LIGHTGREEN; // ÊàñÂÖ∂‰ªñÁªøËâ≤

          viewer.scene.globe.enableLighting = false;
          viewer.scene.fxaa = true;
          viewer.scene.highDynamicRange = false;

          const tileset = viewer.scene.primitives.add(
            await Cesium.Cesium3DTileset.fromUrl(
              "https://gl.hangzhoudk.com/modelfile/tileset.json",
              { debugShowBoundingVolume: false }
            )
          );
          viewer.zoomTo(tileset);

          hideLoading();

          loadBuildingsOptimized("./buildings_simple.csv", viewer);

          viewer.scene.preRender.addEventListener(() => {
            if (dynamicPrimitive && dynamicPrimitive.appearance) {
              dynamicPrimitive.appearance.material.uniforms.u_time =
                performance.now() * 0.001;
            }
          });

          //tileset.customShader = shader
        } catch (error) {
          console.error("ÂàùÂßãÂåñ Cesium Â§±Ë¥•:", error);
          showError("ÂàùÂßãÂåñÂ§±Ë¥•");
        }
      }

      function showError(message) {
        const loadingDiv = document.getElementById("loading");
        if (loadingDiv) {
          loadingDiv.innerHTML = message;
          setTimeout(() => {
            loadingDiv.classList.add("hidden");
          }, 3000);
        }
      }

      function hideLoading() {
        const loadingDiv = document.getElementById("loading");
        if (loadingDiv) {
          setTimeout(() => {
            loadingDiv.classList.add("hidden");
          }, 1000);
        }
      }

      function updateProgress(percent) {
        const progressSpan = document.getElementById("progress");
        if (progressSpan) {
          progressSpan.textContent = percent;
        }
      }

      function parseWKTCoordinates(wkt) {
        try {
          const cleanWkt = wkt.replace(/^"|"$/g, "").trim();
          const match = cleanWkt.match(/\(\(\(([^)]+)\)\)\)/);
          if (!match) return null;

          const coordsStr = match[1];
          const coordPairs = coordsStr.split(",");
          const coordinates = [];

          for (let pair of coordPairs) {
            const trimmedPair = pair.trim();
            if (trimmedPair) {
              const [lonStr, latStr] = trimmedPair.split(" ");
              const lon = parseFloat(lonStr);
              const lat = parseFloat(latStr);

              if (
                !isNaN(lon) &&
                !isNaN(lat) &&
                isFinite(lon) &&
                isFinite(lat)
              ) {
                coordinates.push(lon, lat);
              } else {
                return null;
              }
            }
          }

          if (coordinates.length === 0 || coordinates.length % 2 !== 0) {
            return null;
          }

          return coordinates;
        } catch (error) {
          console.error("Ëß£Êûê WKT ÂùêÊ†áÊó∂Âá∫Èîô:", error);
          return null;
        }
      }

      // ‰ΩøÁî® Turf.js Êâ©Â§ßÂª∫Á≠ëÁâ©ËΩÆÂªìÔºàÂçï‰ΩçÔºöÁ±≥Ôºâ
      function expandPolygon(coordinates, bufferMeters = 6) {
        try {
          const ring = [];
          for (let i = 0; i < coordinates.length; i += 2) {
            ring.push([coordinates[i], coordinates[i + 1]]);
          }

          // Á°Æ‰øùÈó≠Âêà
          if (
            ring.length > 0 &&
            !(
              Math.abs(ring[0][0] - ring[ring.length - 1][0]) < 1e-10 &&
              Math.abs(ring[0][1] - ring[ring.length - 1][1]) < 1e-10
            )
          ) {
            ring.push(ring[0]);
          }

          const polygon = turf.polygon([ring]);
          const buffered = turf.buffer(polygon, bufferMeters / 1000, {
            units: "kilometers",
          });
          const expandedRing = buffered.geometry.coordinates[0];
          const expandedCoords = [];

          for (const point of expandedRing) {
            expandedCoords.push(point[0], point[1]);
          }

          return expandedCoords;
        } catch (e) {
          console.error("Êâ©Â§ßÂ§öËæπÂΩ¢Â§±Ë¥•:", e);
          return null;
        }
      }

      function createBuildingInstance(coordinates, height, bottomHeight, id) {
        try {
          const polygonHierarchy = new Cesium.PolygonHierarchy(
            Cesium.Cartesian3.fromDegreesArray(coordinates)
          );

          const geometry = new Cesium.PolygonGeometry({
            polygonHierarchy: polygonHierarchy,
            height: bottomHeight,
            extrudedHeight: height + 2,
            vertexFormat: Cesium.PerInstanceColorAppearance.VERTEX_FORMAT,
            closeTop: true,
            closeBottom: true,
          });

          return new Cesium.GeometryInstance({
            id: `building_${id}`,
            geometry: geometry,
            attributes: {
              color: Cesium.ColorGeometryInstanceAttribute.fromColor(
                // ‰ΩøÁî®ÊµÖÁÅ∞ÁôΩËâ≤ÔºöGainsboro ÊàñËá™ÂÆö‰πâÁÅ∞ÁôΩ
                Cesium.Color.GAINSBORO.withAlpha(0.9) // #DCDCDCÔºåÂÅèÁÅ∞ÁöÑ‚ÄúÁôΩ‚Äù
                //Cesium.Color.WHITE.withAlpha(1) ,// #DCDCDCÔºåÂÅèÁÅ∞ÁöÑ‚ÄúÁôΩ‚Äù
                //material: Cesium.Color.BLUE.withAlpha(0.7), // ËìùËâ≤ÂçäÈÄèÊòé
                // Êàñ‰ΩøÁî®Ôºönew Cesium.Color(0.9, 0.9, 0.92, 0.8) // R:230, G:230, B:234
              ),
            },
          });
        } catch (error) {
          console.error("ÂàõÂª∫Âª∫Á≠ëÁâ©ÂÆû‰æãÂ§±Ë¥•:", error);
          return null;
        }
      }

      function flyToBuildingCenter(coordinates, viewer) {
        if (!coordinates || coordinates.length === 0) return false;

        let lonSum = 0,
          latSum = 0;
        const count = coordinates.length / 2;
        for (let i = 0; i < coordinates.length; i += 2) {
          lonSum += coordinates[i];
          latSum += coordinates[i + 1];
        }
        const centerLon = lonSum / count;
        const centerLat = latSum / count;

        const destination = Cesium.Cartesian3.fromDegrees(
          centerLon,
          centerLat,
          100
        );

        viewer.camera.flyTo({
          destination: destination,
          duration: 2.0,
          orientation: {
            heading: 0.0,
            pitch: -Cesium.Math.toRadians(30),
            roll: 0.0,
          },
        });

        return true;
      }

      async function loadBuildingsOptimized(url, viewer) {
        try {
          const response = await fetch(url);
          const text = await response.text();
          const lines = text.trim().split("\n");

          console.log(`ÂºÄÂßãÂä†ËΩΩ ${lines.length} ‰∏™Âª∫Á≠ëÁâ©...`);
          updateProgress("0");

          const batchSize = 100;
          let processedCount = 0;
          let buildingInstances = [];
          let firstBuildingCoordinates = null;

          for (let i = 0; i < lines.length; i += batchSize) {
            const batch = lines.slice(i, Math.min(i + batchSize, lines.length));

            for (const line of batch) {
              if (!line.trim()) continue;

              try {
                const parts = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
                if (parts.length < 2) continue;

                const wkt = parts[0].replace(/^"|"$/g, "").trim();
                const height = parseFloat(
                  parts[1].replace(/^"|"$/g, "").trim()
                );

                if (isNaN(height) || !isFinite(height)) continue;

                const coordinates = parseWKTCoordinates(wkt);
                if (!coordinates) continue;

                // üëâ ‰ΩøÁî®Êâ©Â§ßÂêéÁöÑËΩÆÂªìÔºàÊØîÂÆûÈôÖÂ§ß 3 Á±≥Ôºâ
                const expandedCoordinates = expandPolygon(coordinates, 5);
                const finalCoordinates = expandedCoordinates || coordinates; // ÈôçÁ∫ß‰ΩøÁî®ÂéüÂùêÊ†á

                const bottomHeight = 0;
                const instance = createBuildingInstance(
                  finalCoordinates,
                  height,
                  bottomHeight,
                  processedCount
                );
                if (instance) {
                  buildingInstances.push(instance);

                  if (!firstBuildingCoordinates) {
                    firstBuildingCoordinates = finalCoordinates;
                  }
                }
              } catch (error) {
                console.warn("Â§ÑÁêÜË°åÊï∞ÊçÆÂ§±Ë¥•:", error);
              }

              processedCount++;
            }

            const progress = Math.round((processedCount / lines.length) * 100);
            updateProgress(progress.toString());

            await new Promise((resolve) => setTimeout(resolve, 0));
          }

          console.log(`ÊàêÂäüÂàõÂª∫ ${buildingInstances.length} ‰∏™Âª∫Á≠ëÁâ©ÂÆû‰æã`);

          if (buildingInstances.length > 0) {
            // ‚≠ê ‰øùÂ≠ò primitive ÂºïÁî® ‚≠ê
            dynamicPrimitive = new Cesium.Primitive({
              geometryInstances: buildingInstances,

              appearance: new Cesium.MaterialAppearance({
                material: new Cesium.Material({
                  fabric: {
                    type: "CustomMaterialFlow",
                    uniforms: {
                      u_time: 0.0,
                    },
                    source: `
                czm_material czm_getMaterial(czm_materialInput materialInput)
                {
                    czm_material material = czm_getDefaultMaterial(materialInput);

                    float h = materialInput.st.t; 

                    float t = abs(sin(u_time + h * 5.0));

                    material.diffuse = vec3(t, 0.5 * t, 1.0 - t);
                    material.alpha = 1.0;

                    return material;
                }
            `,
                  },
                }),
                translucent: false,
              }),

              releaseGeometryInstances: true,
              allowPicking: false,
            });

            viewer.scene.primitives.add(dynamicPrimitive);

            console.log("Âª∫Á≠ëÁâ©ÔºàÊâ©Â§ßÁâàÔºâÊ∏≤ÊüìÂÆåÊàê");

            // setTimeout(() => {
            //   flyToBuildingCenter(firstBuildingCoordinates, viewer);
            // }, 1000);
          }

          setTimeout(() => {
            hideLoading();
          }, 1000);
        } catch (error) {
          console.error("Âä†ËΩΩÂª∫Á≠ëÁâ©Êï∞ÊçÆÊó∂Âá∫Èîô:", error);
          showError("Âä†ËΩΩÂ§±Ë¥•");
        }
      }

      initializeApp();
    </script>
  </body>
</html>
