<!DOCTYPE html>
<html lang="en">

<head>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.130/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.130/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    html,
    body,
    #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <div id="cesiumContainer"></div>
  <script type="module">
    // Your access token can be found at: https://ion.cesium.com/tokens.  
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1OGIzZmQyZC03YjNiLTQzMjQtOWQxYS0xOTYxZWUyMTYzMjQiLCJpZCI6MzEzMjQxLCJpYXQiOjE3NTAyMjc2NDd9.G9X0WofFDt3mbp2L_WDzU__rcAVg0v3rpAliG1sgB9k';

    // å…ˆåˆ›å»ºåœ°å½¢æä¾›è€…
    const terrainProvider = await Cesium.CesiumTerrainProvider.fromIonAssetId(1, {
      requestVertexNormals: true,
      requestWaterMask: true
    });

    const viewer = new Cesium.Viewer("cesiumContainer", {
      shouldDebug: true,
      terrainProvider: terrainProvider
    });

    // å­˜å‚¨åˆ›å»ºçš„å®ä½“
    let droneEntity = null;
    let rayEntities = [];

    //åŠ è½½ 3D Tilesetï¼ˆè‡ªåŠ¨è§£æ B3DMï¼‰
    const tileset = viewer.scene.primitives.add(
      await Cesium.Cesium3DTileset.fromUrl(
        "https://gl.hangzhoudk.com/modelfile/tileset.json",
        {
          debugShowBoundingVolume: true,
        })
    );

    tileset.loadProgress.addEventListener((numberOfPendingRequests) => {
      console.log(`æ­£åœ¨åŠ è½½: ${numberOfPendingRequests} ä¸ªè¯·æ±‚`);
    });

    // å®šä½åˆ° Tileset
    viewer.zoomTo(tileset);
    const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);

    handler.setInputAction(async (click) => {
      try {
        console.log('å•å‡»äº‹ä»¶: ', click);
        // æ¸…é™¤ä¹‹å‰çš„æ— äººæœºå’Œå°„çº¿
        if (droneEntity) {
          viewer.entities.remove(droneEntity);
          droneEntity = null;
        }

        // æ¸…é™¤ä¹‹å‰çš„å°„çº¿å®ä½“
        rayEntities.forEach(entity => {
          viewer.entities.remove(entity);
        });
        rayEntities = [];

        // === è·å–ç‚¹å‡»çš„å±å¹•åæ ‡ï¼ˆCartesian2ï¼‰===
        const cartesian2 = click.position; // è¿™æ˜¯ Cesium.ScreenSpaceEventHandler æä¾›çš„æ­£ç¡®åæ ‡
        if (!cartesian2) {
          console.warn("æœªè·å–åˆ°å±å¹•åæ ‡");
          return;
        }

        // === ä»å±å¹•åæ ‡æ‹¾å– 3D ä¸–ç•Œåæ ‡ ===
        const pickedPoint = viewer.scene.pickPosition(cartesian2);
        if (!Cesium.defined(pickedPoint)) {
          console.warn("æ— æ³•è·å–ç‚¹å‡»ä½ç½®çš„3Dåæ ‡ï¼ˆå¯èƒ½ç‚¹å‡»äº†å¤©ç©ºï¼‰");
          return;
        }

        // === è½¬æ¢ä¸ºç»çº¬åº¦ ===
        const cartographic = Cesium.Cartographic.fromCartesian(pickedPoint);
        if (!cartographic) {
          console.warn("æ— æ³•å°†3Dåæ ‡è½¬æ¢ä¸ºåœ°ç†åæ ‡");
          return;
        }

        const longitude_click = Cesium.Math.toDegrees(cartographic.longitude);
        const latitude_click = Cesium.Math.toDegrees(cartographic.latitude);
        const height_click = 100; // æ— äººæœºæ‚¬åœé«˜åº¦è®¾ä¸º300ç±³

        // ä½¿ç”¨å›ºå®šçš„å»ºç­‘ç‰©ä¸­å¿ƒç‚¹åæ ‡
        //const longitude_click = 119.9980574;
        //const latitude_click = 30.28275965;

        console.log("ç‚¹å‡»åæ ‡ï¼ˆç»çº¬åº¦ï¼‰:", { longitude_click, latitude_click, height_click });

        // è·å–åœ°å½¢é«˜åº¦
        const terrainSample = await Cesium.sampleTerrainMostDetailed(
          viewer.terrainProvider,
          [new Cesium.Cartographic(
            Cesium.Math.toRadians(longitude_click),
            Cesium.Math.toRadians(latitude_click)
          )]
        );

        if (!terrainSample || terrainSample.length === 0) {
          console.error("æ— æ³•è·å–åœ°å½¢é«˜åº¦");
          return;
        }

        // è·å–åœ°å½¢é«˜åº¦
        const terrainHeight = terrainSample[0].height;
        console.log("åœ°å½¢é«˜åº¦:", terrainHeight.toFixed(2), "ç±³");

        // åˆ›å»ºæ— äººæœºä½ç½®
        const dronePositionCartesian = Cesium.Cartesian3.fromDegrees(
          longitude_click,
          latitude_click,
          height_click
        );

        // è·å–æ— äººæœºæ¨¡å‹
        const airplaneUri = await Cesium.IonResource.fromAssetId(3472138);

        const heading = Cesium.Math.toRadians(-90); // æ°´å¹³æ–¹å‘åè½¬90åº¦
        const pitch = Cesium.Math.toRadians(0);    // ä¿¯ä»°è§’ 0 åº¦
        const roll = Cesium.Math.toRadians(0);     // æ»šè½¬è§’ 0 åº¦

        const hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
        const orientation = Cesium.Transforms.headingPitchRollQuaternion(
          dronePositionCartesian,
          hpr
        );

        // åˆ›å»ºæ–°çš„æ— äººæœºå®ä½“
        droneEntity = viewer.entities.add({
          name: "æ— äººæœº",
          position: dronePositionCartesian,
          orientation: orientation,
          model: {
            uri: "models/drone_costum.glb",
            scale: 5.0,
            minimumPixelSize: 64
          }
        });

        // è§†è§’èšç„¦åˆ°æ— äººæœº
        viewer.zoomTo(droneEntity, new Cesium.HeadingPitchRange(
          Cesium.Math.toRadians(-90),
          Cesium.Math.toRadians(-15),
          2000
        ));

        // ç”Ÿæˆé”¥å½¢å°„çº¿ï¼ˆå‚ç›´å‘ä¸‹ä¸ºä¸­å¿ƒï¼‰
        const coneRays = generateSphericalRays(dronePositionCartesian, 60, 60); //

        let collisionDetected = false;

        // å¤„ç†æ¯æ¡å°„çº¿
        coneRays.forEach((rayInfo, rayIndex) => {
          const ray = new Cesium.Ray(dronePositionCartesian, rayInfo.direction);

          // å¯è§†åŒ–å°„çº¿
          const rayEntity = viewer.entities.add({
            name: `å°„çº¿_${rayIndex}`,
            polyline: {
              positions: [
                dronePositionCartesian,
                Cesium.Cartesian3.add(
                  dronePositionCartesian,
                  Cesium.Cartesian3.multiplyByScalar(
                    rayInfo.direction,
                    500, // å°„çº¿é•¿åº¦
                    new Cesium.Cartesian3()
                  ),
                  new Cesium.Cartesian3()
                )
              ],
              width: rayInfo.isCenterRay ? 6 : 4,
              material: rayInfo.isCenterRay ?
                new Cesium.PolylineOutlineMaterialProperty({
                  color: Cesium.Color.RED,
                  outlineColor: Cesium.Color.BLACK,
                  outlineWidth: 1
                }) :
                new Cesium.PolylineGlowMaterialProperty({
                  color: Cesium.Color.BLUE.withAlpha(0.7),
                  glowPower: 0.1
                })
            }
          });
          rayEntities.push(rayEntity);

          // å°„çº¿æ£€æµ‹
          const hitPoint = viewer.scene.pickFromRay(ray);
          if (!hitPoint) {
            console.log(`âŒ å°„çº¿${rayIndex}æœªç©¿è¿‡ä»»ä½•ç‰©ä½“`);
            return;
          }

          if (hitPoint.position) {
            const cartographicHit = Cesium.Cartographic.fromCartesian(hitPoint.position);
            const distance = Cesium.Cartesian3.distance(dronePositionCartesian, hitPoint.position);

            // è®¡ç®—å»ºç­‘ç‰©é«˜åº¦
            const buildingHeight = Math.max(0, cartographicHit.height - terrainHeight);

            console.log(
              `ğŸ“ å°„çº¿${rayIndex}ç¢°æ’ç‚¹: ç»åº¦=${Cesium.Math.toDegrees(cartographicHit.longitude).toFixed(6)}, ` +
              `çº¬åº¦=${Cesium.Math.toDegrees(cartographicHit.latitude).toFixed(6)}, ` +
              `åœ°å½¢é«˜åº¦=${terrainHeight.toFixed(2)}ç±³, ` +
              `ç¢°æ’ç‚¹é«˜åº¦=${cartographicHit.height.toFixed(2)}ç±³, ` +
              `å»ºç­‘ç‰©é«˜åº¦=${buildingHeight.toFixed(2)}ç±³, ` +
              `è·ç¦»=${distance.toFixed(2)}ç±³`
            );

            if (distance < 500) { // æ‰©å¤§æ£€æµ‹èŒƒå›´
              console.log(`ğŸ¨ å°„çº¿${rayIndex}æ£€æµ‹åˆ°è¿‘è·ç¦»ç‰©ä½“`);

              // å¯è§†åŒ–å‘½ä¸­ç‚¹
              const hitEntity = viewer.entities.add({
                name: `ç¢°æ’ç‚¹_${rayIndex}`,
                position: hitPoint.position,
                point: {
                  pixelSize: rayInfo.isCenterRay ? 30 : 20,
                  color: distance < 100 ? Cesium.Color.RED :
                    distance < 200 ? Cesium.Color.ORANGE : Cesium.Color.YELLOW,
                  outlineColor: Cesium.Color.WHITE,
                  outlineWidth: 2
                },
                label: {
                  text: `é«˜åº¦: ${buildingHeight.toFixed(1)}m\nè·ç¦»: ${distance.toFixed(1)}m`,
                  font: '12px sans-serif',
                  fillColor: Cesium.Color.WHITE,
                  outlineColor: Cesium.Color.BLACK,
                  outlineWidth: 2,
                  style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                  pixelOffset: new Cesium.Cartesian2(0, -30)
                }
              });
              rayEntities.push(hitEntity);

              collisionDetected = true;
            } else {
              console.log(`âš ï¸ å°„çº¿${rayIndex}è·ç¦»å¤§äº500mï¼Œè·³è¿‡`);
            }
          }
        });

        if (!collisionDetected) {
          console.log("âœ… æœªæ£€æµ‹åˆ°è¿‘è·ç¦»éšœç¢ç‰©");
        }

      } catch (error) {
        console.error("å¤„ç†è¿‡ç¨‹ä¸­å‡ºé”™:", error);
      }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    // ç”Ÿæˆå‚ç›´å‘ä¸‹çš„å°„çº¿æ–¹å‘ï¼ˆå±€éƒ¨åæ ‡ç³»ï¼‰
    function getLocalDownDirection(position) {
      // è·å–ä½ç½®çš„å±€éƒ¨ä¸œåŒ—å¤©(ENU)åæ ‡ç³»
      const enuMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);

      // ä»ENUçŸ©é˜µä¸­æå–"ä¸‹"æ–¹å‘ï¼ˆENUä¸­çš„Downæ˜¯-Zè½´ï¼‰
      const downDirection = new Cesium.Cartesian3();
      Cesium.Matrix4.multiplyByPointAsVector(
        enuMatrix,
        new Cesium.Cartesian3(0, 0, -1),
        downDirection
      );

      Cesium.Cartesian3.normalize(downDirection, downDirection);
      return downDirection;
    }

    // ç”Ÿæˆé”¥å½¢åˆ†å¸ƒçš„å°„çº¿
    function generateConeRays(origin, rayCount = 12, coneAngle = 30) {
      const rays = [];

      // è·å–å±€éƒ¨åæ ‡ç³»çš„"ä¸‹"æ–¹å‘
      const localDown = getLocalDownDirection(origin);

      // è·å–å±€éƒ¨åæ ‡ç³»çš„å˜æ¢çŸ©é˜µ
      const enuMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);
      const inverseEnuMatrix = Cesium.Matrix4.inverse(enuMatrix, new Cesium.Matrix4());

      if (rayCount === 1) {
        // åªç”Ÿæˆä¸€ä¸ªå‚ç›´å‘ä¸‹çš„å°„çº¿
        rays.push({
          direction: localDown,
          isCenterRay: true
        });
        return rays;
      }

      // ç”Ÿæˆé”¥å½¢å°„çº¿
      for (let i = 0; i < rayCount; i++) {
        if (i === 0) {
          // ä¸­å¿ƒå°„çº¿ï¼šå‚ç›´å‘ä¸‹
          rays.push({
            direction: localDown,
            horizontalAngle: 0,
            verticalAngle: 0,
            isCenterRay: true
          });
        } else {
          // é”¥å½¢å‘¨å›´çš„å°„çº¿
          const surroundingRays = rayCount - 1;
          const index = i - 1;

          const horizontalAngle = (index / surroundingRays) * 2 * Math.PI;
          const coneAngleRad = Cesium.Math.toRadians(coneAngle);

          // åœ¨å±€éƒ¨ENUåæ ‡ç³»ä¸­è®¡ç®—æ–¹å‘
          const x = Math.sin(coneAngleRad) * Math.cos(horizontalAngle); // ä¸œå‘åˆ†é‡
          const y = Math.sin(coneAngleRad) * Math.sin(horizontalAngle); // åŒ—å‘åˆ†é‡
          const z = -Math.cos(coneAngleRad); // ä¸‹å‘åˆ†é‡ï¼ˆè´Ÿå·è¡¨ç¤ºå‘ä¸‹ï¼‰

          // è½¬æ¢åˆ°ä¸–ç•Œåæ ‡ç³»
          const localDirection = new Cesium.Cartesian3(x, y, z);
          const worldDirection = new Cesium.Cartesian3();

          Cesium.Matrix4.multiplyByPointAsVector(enuMatrix, localDirection, worldDirection);
          Cesium.Cartesian3.normalize(worldDirection, worldDirection);

          rays.push({
            direction: worldDirection,
            horizontalAngle: Cesium.Math.toDegrees(horizontalAngle),
            verticalAngle: coneAngle,
            isCenterRay: false
          });
        }
      }

      return rays;
    }


    function generateSphericalRays(origin, latStepDegrees = 30, lonStepDegrees = 30) {
      const rays = [];

      // è·å–å±€éƒ¨åæ ‡ç³»ENUçŸ©é˜µï¼ˆä¸œ-åŒ—-å¤©ï¼‰
      const enuMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);

      // çº¬åº¦ä» -90Â°ï¼ˆå—æï¼‰åˆ° +90Â°ï¼ˆåŒ—æï¼‰
      for (let lat = -90; lat <= 90; lat += latStepDegrees) {
        const latRad = Cesium.Math.toRadians(lat);

        // ç»åº¦ä» 0Â° åˆ° 360Â°
        // åœ¨ä¸¤ææ—¶ï¼Œåªéœ€è¦ä¸€ä¸ªç‚¹å³å¯ï¼ˆé¿å…é‡å¤ï¼‰
        const lonCount = (lat === -90 || lat === 90) ? 1 : Math.floor(360 / lonStepDegrees);

        for (let i = 0; i < lonCount; i++) {
          const lon = i * lonStepDegrees;
          const lonRad = Cesium.Math.toRadians(lon);

          // çƒé¢åæ ‡è½¬æ¢ä¸ºå±€éƒ¨ ENU åæ ‡ (x: East, y: North, z: Up)
          // çƒé¢åæ ‡å®šä¹‰ï¼š
          // x = cos(lat) * cos(lon)
          // y = cos(lat) * sin(lon)
          // z = sin(lat)
          const x = Math.cos(latRad) * Math.cos(lonRad);
          const y = Math.cos(latRad) * Math.sin(lonRad);
          const z = Math.sin(latRad);

          const localDirection = new Cesium.Cartesian3(x, y, z);

          // è½¬æ¢ä¸ºä¸–ç•Œåæ ‡ç³»æ–¹å‘å‘é‡
          const worldDirection = new Cesium.Cartesian3();
          Cesium.Matrix4.multiplyByPointAsVector(enuMatrix, localDirection, worldDirection);
          Cesium.Cartesian3.normalize(worldDirection, worldDirection);

          rays.push({
            direction: worldDirection,
            latitude: lat,
            longitude: lon,
            isCenterRay: false
          });
        }
      }

      return rays;
    }


    function generateSixFixedRays(origin) {
      const rays = [];
      const enuMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);

      // ENUå±€éƒ¨åæ ‡ç³»ä¸­çš„6ä¸ªæ–¹å‘å‘é‡ï¼ˆå•ä½å‘é‡ï¼‰
      const localDirections = [
        new Cesium.Cartesian3(0, 0, 1),   // ä¸Š (å¤©)
        new Cesium.Cartesian3(0, 0, -1),  // ä¸‹ (åœ°)
        new Cesium.Cartesian3(1, 0, 0),   // ä¸œ
        new Cesium.Cartesian3(0, 1, 0),   // åŒ—
        new Cesium.Cartesian3(-1, 0, 0),  // è¥¿
        new Cesium.Cartesian3(0, -1, 0),  // å—
      ];

      localDirections.forEach((localDir, index) => {
        const worldDir = new Cesium.Cartesian3();
        Cesium.Matrix4.multiplyByPointAsVector(enuMatrix, localDir, worldDir);
        Cesium.Cartesian3.normalize(worldDir, worldDir);
        rays.push({
          direction: worldDir,
          description: ['ä¸Š', 'ä¸‹', 'ä¸œ', 'åŒ—', 'è¥¿', 'å—'][index],
          isCenterRay: false
        });
      });

      return rays;
    }

  </script>
</body>

</html>