<!DOCTYPE html>
<html lang="en">

<head>
  <script src="https://cdn.jsdelivr.net/npm/cesium@1.130/Build/Cesium/Cesium.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/cesium@1.130/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <style>
    html,
    body,
    #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    #threeContainer {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>
  <div id="cesiumContainer"></div>
  <div id="threeContainer"></div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';

    // === 初始化 Cesium ===
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1OGIzZmQyZC03YjNiLTQzMjQtOWQxYS0xOTYxZWUyMTYzMjQiLCJpZCI6MzEzMjQxLCJpYXQiOjE3NTAyMjc2NDd9.G9X0WofFDt3mbp2L_WDzU__rcAVg0v3rpAliG1sgB9k';
    const terrainProvider = await Cesium.CesiumTerrainProvider.fromIonAssetId(1, {
      requestVertexNormals: true,
      requestWaterMask: true
    });
    const viewer = new Cesium.Viewer("cesiumContainer", {
      terrainProvider: terrainProvider
    });

    const tileset = viewer.scene.primitives.add(
      await Cesium.Cesium3DTileset.fromUrl("http://192.168.4.78:8000/tileset.json")
    );
    viewer.zoomTo(tileset);

    // === Three.js 场景（雨滴层）===
    const threeContainer = document.getElementById('threeContainer');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    threeContainer.appendChild(renderer.domElement);

    // === 雨滴粒子 ===
    const rainCount = 40000; // 更密集
    const rainGeo = new THREE.BufferGeometry();
    const positions = [];
    const sizes = [];
    const opacities = [];
    const rainData = [];

    const rainTexture = createRainDropTexture();

    for (let i = 0; i < rainCount; i++) {
      const x = (Math.random() - 0.5) * 400;
      const y = Math.random() * 200;
      const z = (Math.random() - 0.5) * 400;
      positions.push(x, y, z);

      const dist = Math.abs(z);
      const size = THREE.MathUtils.lerp(0.5, 1.2, dist / 200); // 近小远大
      sizes.push(size);

      const opacity = THREE.MathUtils.clamp(1.0 - dist / 400, 0.2, 1.0); // 近明显远淡
      opacities.push(opacity);

      rainData.push({
        velocity: 0.8 + Math.random() * 1.2,
        size: size,
        opacity: opacity,
        windOffset: (Math.random() - 0.5) * 0.5
      });
    }

    rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    rainGeo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

    const rainMaterial = new THREE.PointsMaterial({
      size: 2,
      map: rainTexture,
      color: new THREE.Color(0x87cefa), // 淡蓝色
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    const rainParticles = new THREE.Points(rainGeo, rainMaterial);
    scene.add(rainParticles);

    // === 动画 ===
    function animate() {
      requestAnimationFrame(animate);

      const positions = rainGeo.attributes.position.array;
      const sizes = rainGeo.attributes.size.array;

      for (let i = 0; i < rainCount; i++) {
        const idx = i * 3;
        positions[idx + 1] -= rainData[i].velocity; // 下落
        positions[idx] += rainData[i].windOffset;   // 风偏移

        if (positions[idx + 1] < -100) {
          positions[idx + 1] = 100;
          positions[idx] = (Math.random() - 0.5) * 400;
          positions[idx + 2] = (Math.random() - 0.5) * 400;
          rainData[i].windOffset = (Math.random() - 0.5) * 0.5;
        }

        // 远近调整尺寸和透明度
        sizes[i] = rainData[i].size;
        rainMaterial.opacity = rainData[i].opacity;
      }

      rainGeo.attributes.position.needsUpdate = true;
      rainGeo.attributes.size.needsUpdate = true;
      renderer.render(scene, camera);
    }
    animate();

    // === 淡蓝雨滴纹理 ===
    function createRainDropTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 16;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');

      const gradient = ctx.createLinearGradient(0, 0, 0, 64);
      gradient.addColorStop(0, 'rgba(135,206,250,0.5)'); // 顶部透明淡蓝
      gradient.addColorStop(1, 'rgba(135,206,250,1.0)'); // 底部淡蓝

      ctx.fillStyle = gradient;
      ctx.fillRect(7, 0, 2, 64);

      return new THREE.CanvasTexture(canvas);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>

</body>

</html>