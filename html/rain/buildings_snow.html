<!DOCTYPE html>
<html lang="en">

<head>
  <script src="https://cdn.jsdelivr.net/npm/cesium@1.130/Build/Cesium/Cesium.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/cesium@1.130/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <style>
    html,
    body,
    #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    #threeContainer {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      /* 不阻止 Cesium 交互 */
      width: 100%;
      height: 100%;
    }
  </style>
</head>

<body>
  <div id="cesiumContainer"></div>
  <div id="threeContainer"></div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';

    // === 初始化 Cesium ===
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1OGIzZmQyZC03YjNiLTQzMjQtOWQxYS0xOTYxZWUyMTYzMjQiLCJpZCI6MzEzMjQxLCJpYXQiOjE3NTAyMjc2NDd9.G9X0WofFDt3mbp2L_WDzU__rcAVg0v3rpAliG1sgB9k';
    const terrainProvider = await Cesium.CesiumTerrainProvider.fromIonAssetId(1, {
      requestVertexNormals: true,
      requestWaterMask: true
    });
    const viewer = new Cesium.Viewer("cesiumContainer", {
      terrainProvider: terrainProvider
    });

    const tileset = viewer.scene.primitives.add(
      await Cesium.Cesium3DTileset.fromUrl("http://192.168.4.78:8000/tileset.json")
    );
    viewer.zoomTo(tileset);

    // === 初始化 Three.js 雪花 ===
    const threeContainer = document.getElementById('threeContainer');
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0); // 透明背景
    threeContainer.appendChild(renderer.domElement);

    // 雪花粒子
    const snowCount = 80000;
    const snowGeo = new THREE.BufferGeometry();
    const positions = [];
    const sizes = [];
    const snowData = [];

    const snowTextures = [
      createCircleSnowTexture(),
      createHexSnowTexture(),
      createStarSnowTexture()
    ];

    for (let i = 0; i < snowCount; i++) {
      const x = (Math.random() - 0.5) * 400;
      const y = Math.random() * 200;
      const z = (Math.random() - 0.5) * 400;
      positions.push(x, y, z);

      //const size = 1 + (50 - Math.abs(z)) * 0.05 + Math.random() * 1.5;
      // 近处（z≈0）→ 大
      // 中远处（z大）→ 稍大
      // 保持平滑过渡
      const distance = Math.abs(z);
      const size = 1 - distance * 0.01 + Math.min(distance / 200, 1.0) + Math.random() * 1.0;
      sizes.push(size);

      const alpha = THREE.MathUtils.clamp(1 - Math.abs(z) / 100, 0.3, 1);

      snowData.push({
        velocity: 0.2 + Math.random() * 0.5,
        rotation: Math.random() * 2 * Math.PI,
        rotationSpeed: (Math.random() - 0.5) * 0.02,
        texture: snowTextures[Math.floor(Math.random() * snowTextures.length)],
        size: size,
        opacity: alpha
      });
    }

    snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    snowGeo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

    const snowMaterial = new THREE.PointsMaterial({
      size: 2,
      map: snowTextures[2],
      vertexColors: false,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    const snowParticles = new THREE.Points(snowGeo, snowMaterial);
    scene.add(snowParticles);

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // === 动画循环 ===
    function animate() {
      requestAnimationFrame(animate);

      const positions = snowGeo.attributes.position.array;
      const sizes = snowGeo.attributes.size.array;

      for (let i = 0; i < snowCount; i++) {
        const idx = i * 3;
        positions[idx + 1] -= snowData[i].velocity;

        if (positions[idx + 1] < -100) {
          positions[idx + 1] = 100;
          positions[idx] = (Math.random() - 0.5) * 400;
          positions[idx + 2] = (Math.random() - 0.5) * 400;
        }

        positions[idx] += Math.sin(snowData[i].rotation) * 0.05;
        positions[idx + 2] += Math.cos(snowData[i].rotation) * 0.05;
        snowData[i].rotation += snowData[i].rotationSpeed;
        sizes[i] = snowData[i].size;
      }

      snowGeo.attributes.position.needsUpdate = true;
      snowGeo.attributes.size.needsUpdate = true;

      renderer.render(scene, camera);
    }

    animate();

    // === 雪花纹理生成函数 ===
    function createCircleSnowTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(32, 32, 28, 0, Math.PI * 2);
      ctx.fill();
      return new THREE.CanvasTexture(canvas);
    }

    function createHexSnowTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 3 * i;
        const x = 32 + 20 * Math.cos(angle);
        const y = 32 + 20 * Math.sin(angle);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.stroke();
      return new THREE.CanvasTexture(canvas);
    }

    function createStarSnowTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < 8; i++) {
        const angle = Math.PI / 4 * i;
        const x1 = 32 + 20 * Math.cos(angle);
        const y1 = 32 + 20 * Math.sin(angle);
        const x2 = 32 - 20 * Math.cos(angle);
        const y2 = 32 - 20 * Math.sin(angle);
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
      }
      ctx.stroke();
      return new THREE.CanvasTexture(canvas);
    }

  </script>
</body>

</html>