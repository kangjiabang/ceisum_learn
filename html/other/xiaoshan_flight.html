<!DOCTYPE html>
<html lang="en">

<head>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.130/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.130/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    #cesiumContainer {
      width: 100%;
      height: 100vh;
    }
  </style>
</head>

<body>
  <div id="cesiumContainer">
  </div>
  <script type="module">
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1OGIzZmQyZC03YjNiLTQzMjQtOWQxYS0xOTYxZWUyMTYzMjQiLCJpZCI6MzEzMjQxLCJpYXQiOjE3NTAyMjc2NDd9.G9X0WofFDt3mbp2L_WDzU__rcAVg0v3rpAliG1sgB9k';


    const viewer = new Cesium.Viewer("cesiumContainer", {
      shouldDebug: true,
      skyAtmosphere: false,
    });

    function interpolateCatmullRom(p0, p1, p2, p3, t) {
      // t in [0, 1]
      const t2 = t * t;
      const t3 = t2 * t;

      const x = 0.5 * ((2 * p1[0]) +
        (-p0[0] + p2[0]) * t +
        (2 * p0[0] - 5 * p1[0] + 4 * p2[0] - p3[0]) * t2 +
        (-p0[0] + 3 * p1[0] - 3 * p2[0] + p3[0]) * t3);

      const y = 0.5 * ((2 * p1[1]) +
        (-p0[1] + p2[1]) * t +
        (2 * p0[1] - 5 * p1[1] + 4 * p2[1] - p3[1]) * t2 +
        (-p0[1] + 3 * p1[1] - 3 * p2[1] + p3[1]) * t3);

      const z = 0.5 * ((2 * p1[2]) +
        (-p0[2] + p2[2]) * t +
        (2 * p0[2] - 5 * p1[2] + 4 * p2[2] - p3[2]) * t2 +
        (-p0[2] + 3 * p1[2] - 3 * p2[2] + p3[2]) * t3);

      return [x, y, z];
    }


    function generateInterpolatedPoints(waypoints, segments = 10) {
      const positions = [];

      for (let i = 0; i < waypoints.length - 1; i++) {
        // 获取 Catmull-Rom 所需的4个控制点
        const p0 = waypoints[Math.max(0, i - 1)];
        const p1 = waypoints[i];
        const p2 = waypoints[i + 1];
        const p3 = waypoints[Math.min(waypoints.length - 1, i + 2)];

        const pos0 = [p0.lon, p0.lat, p0.alt];
        const pos1 = [p1.lon, p1.lat, p1.alt];
        const pos2 = [p2.lon, p2.lat, p2.alt];
        const pos3 = [p3.lon, p3.lat, p3.alt];

        for (let j = 0; j < segments; j++) {
          const t = j / segments;
          const [lon, lat, alt] = interpolateCatmullRom(pos0, pos1, pos2, pos3, t);
          positions.push({ lon, lat, alt });
        }
      }

      // 添加最后一个点
      positions.push(waypoints[waypoints.length - 1]);
      return positions;
    }

    const rawWaypoints = [
      { lon: 120.712, lat: 31.326, alt: 100 },
      { lon: 120.714, lat: 31.328, alt: 150 },
      { lon: 120.716, lat: 31.327, alt: 200 },
      { lon: 120.718, lat: 31.329, alt: 250 },
      { lon: 120.720, lat: 31.326, alt: 300 },
    ];

    // 插值：每两个点之间插入 10 个平滑点
    const smoothWaypoints = generateInterpolatedPoints(rawWaypoints, 10);

    // 基于时间插值：每个点间隔 2 秒
    const startTime = Cesium.JulianDate.now();
    const sampledPosition = new Cesium.SampledPositionProperty();

    smoothWaypoints.forEach((point, index) => {
      const time = Cesium.JulianDate.addSeconds(startTime, index * 2, new Cesium.JulianDate());
      const position = Cesium.Cartesian3.fromDegrees(point.lon, point.lat, point.alt);
      sampledPosition.addSample(time, position);
    });

    // 加载无人机模型资源
    const airplaneUri = await Cesium.IonResource.fromAssetId(3472138);

    // 创建实体
    const droneEntity = viewer.entities.add({
      name: "无人机",
      availability: new Cesium.TimeIntervalCollection([
        new Cesium.TimeInterval({
          start: startTime,
          stop: Cesium.JulianDate.addSeconds(startTime, smoothWaypoints.length * 2, new Cesium.JulianDate())
        })
      ]),
      position: sampledPosition,
      orientation: new Cesium.VelocityOrientationProperty(sampledPosition),
      model: {
        uri: airplaneUri,
        scale: 1.0,
        minimumPixelSize: 64,
      },
      // path: {
      //   resolution: 10,
      //   material: new Cesium.PolylineGlowMaterialProperty({
      //     glowPower: 0.1,
      //     color: Cesium.Color.YELLOW,
      //   }),
      //   width: 5,
      //   leadTime: 0,
      //   // trailTime: 60,
      //   //leadTime: Number.POSITIVE_INFINITY,   // 显示未来路径
      //   trailTime: Number.POSITIVE_INFINITY,  // 显示过去路径
      // },
    });

    viewer.entities.add({
      name: '完整飞行路径',
      polyline: {
        positions: smoothWaypoints.map(p =>
          Cesium.Cartesian3.fromDegrees(p.lon, p.lat, p.alt)
        ),
        width: 2,
        material: Cesium.Color.CYAN.withAlpha(0.6),
      }
    });

    // ===== 新增：空域图形 =====
    // 1. 圆柱体空域（如禁飞区）
    viewer.entities.add({
      name: '圆柱体空域',
      position: Cesium.Cartesian3.fromDegrees(120.716, 31.328, 0),
      cylinder: {
        length: 500,          // 高度（米）
        topRadius: 0,         // 顶部半径（0 = 圆锥）
        bottomRadius: 2000,   // 底部半径（米）
        material: Cesium.Color.RED.withAlpha(0.3),
        outline: true,
        outlineColor: Cesium.Color.RED,
      }
    });

    // 2. 多边形空域（如管制区）
    viewer.entities.add({
      name: '多边形空域',
      polygon: {
        hierarchy: Cesium.Cartesian3.fromDegreesArrayHeights([
          120.710, 31.325, 200,  // 点1 (lon, lat, alt)
          120.715, 31.325, 200,  // 点2
          120.715, 31.330, 200,  // 点3
          120.710, 31.330, 200,  // 点4
        ]),
        material: Cesium.Color.BLUE.withAlpha(0.2),
        outline: true,
        outlineColor: Cesium.Color.BLUE,
        height: 500,  // 空域高度（米）
        extrudedHeight: 700, // 顶部高度
      }
    });

    // 3. 矩形空域（如雷达覆盖区）
    viewer.entities.add({
      name: '矩形空域',
      rectangle: {
        coordinates: Cesium.Rectangle.fromDegrees(120.700, 31.320, 120.730, 31.335),
        material: Cesium.Color.GREEN.withAlpha(0.1),
        outline: true,
        height: 0,
        extrudedHeight: 0,
      }
    });

    // 设置时间轴
    viewer.clock.startTime = startTime.clone();
    viewer.clock.stopTime = Cesium.JulianDate.addSeconds(startTime, smoothWaypoints.length * 2, new Cesium.JulianDate());
    viewer.clock.currentTime = startTime.clone();
    viewer.clock.clockRange = Cesium.ClockRange.CLAMPED; // 只播放一次
    viewer.clock.multiplier = 1;
    viewer.clock.shouldAnimate = true;

    viewer.timeline.zoomTo(viewer.clock.startTime, viewer.clock.stopTime);
    viewer.trackedEntity = droneEntity;

  </script>
</body>



</html>