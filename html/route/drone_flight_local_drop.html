<!DOCTYPE html>
<html lang="en">

<head>
  <style>
    #cesiumContainer {
      width: 100%;
      height: 100vh;
    }
  </style>
</head>

<body>
  <div id="cesiumContainer">
  </div>
  <script type="module">
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1OGIzZmQyZC03YjNiLTQzMjQtOWQxYS0xOTYxZWUyMTYzMjQiLCJpZCI6MzEzMjQxLCJpYXQiOjE3NTAyMjc2NDd9.G9X0WofFDt3mbp2L_WDzU__rcAVg0v3rpAliG1sgB9k';


    import * as Cesium from 'cesium';
    import DronePath from './src/utils/index.js';

    // åˆå§‹åŒ–Cesium Viewer
    const viewer = new Cesium.Viewer("cesiumContainer", {
      shouldDebug: true,
      skyAtmosphere: false,
    });


    // åˆ›å»ºDronePathå®ä¾‹
    const dronePath = new DronePath(viewer, {
      modelAssetId: 3472138, // å¯é€‰: è‡ªå®šä¹‰æ¨¡å‹ID
      segmentPoints: 10,     // å¯é€‰: æ’å€¼ç‚¹æ•°
      pointInterval: 2       // å¯é€‰: ç‚¹é—´éš”æ—¶é—´
    });

    // å®šä¹‰èˆªç‚¹
    const waypoints = [
      { lon: 120.712, lat: 31.320, alt: 100 },
      { lon: 120.714, lat: 31.328, alt: 150 },
      { lon: 120.716, lat: 31.327, alt: 200 },
      { lon: 120.718, lat: 31.329, alt: 250 },
      { lon: 120.730, lat: 31.320, alt: 300 },
    ];

    // åˆ›å»ºé£è¡Œè·¯å¾„
    await dronePath.createFlightPath(waypoints, {
      name: "æˆ‘çš„æ— äººæœº",
      showPath: true,
      pathColor: Cesium.Color.YELLOW.withAlpha(0.7)
    });

    await dronePath.startFlight();

    // === ç‰©èµ„æŠ•æ”¾åŠŸèƒ½ ===
    let supplyEntity = null;
    let isDropped = false;
    let fallSpeed = 0;
    const gravity = 9.8; // m/sÂ²
    const dropStartTime = null;
    let dropPosition = null;

    // ç›‘å¬æ— äººæœºä½ç½®ï¼Œåœ¨åˆé€‚æ—¶æœºæŠ•æ”¾
    const dropCheckInterval = setInterval(() => {
      const dronePosition = dronePath.getCurrentPosition();
      if (!dronePosition || isDropped) return;

      // ç¤ºä¾‹ï¼šå½“æ— äººæœºé£è¿‡ç¬¬3ä¸ªèˆªç‚¹é™„è¿‘æ—¶æŠ•æ”¾
      const dropWaypoint = Cesium.Cartesian3.fromDegrees(waypoints[2].lon, waypoints[2].lat, waypoints[2].alt);
      const distanceToWaypoint = Cesium.Cartesian3.distance(dronePosition, dropWaypoint);

      if (distanceToWaypoint < 50 && !isDropped) { // è·ç¦»å°äº50ç±³æ—¶æŠ•æ”¾
        isDropped = true;
        clearInterval(dropCheckInterval);

        // è·å–å½“å‰æ— äººæœºé«˜åº¦ä½ç½®ä½œä¸ºèµ·å§‹æŠ•æ”¾ç‚¹
        dropPosition = Cesium.Cartesian3.clone(dronePosition);

        // åˆ›å»ºç‰©èµ„å®ä½“ï¼ˆå°ç«‹æ–¹ä½“æˆ–æ¨¡å‹ï¼‰
        supplyEntity = viewer.entities.add({
          name: "æŠ•æ”¾ç‰©èµ„",
          position: dropPosition,
          box: {
            dimensions: new Cesium.Cartesian3(2, 2, 2), // 2x2x2 ç±³çš„ç®±å­
            material: Cesium.Color.BLUE.withAlpha(0.8),
            outline: true,
            outlineColor: Cesium.Color.WHITE
          }
        });

        console.log("ğŸ“¦ ç‰©èµ„å·²æŠ•æ”¾ï¼Œå¼€å§‹ä¸‹è½ï¼");


        // âœ… æŠ•æ”¾ç‰©èµ„åï¼Œè®¾ç½®åŠ¨æ€ä¸‹è½ä½ç½®
        const initialCartographic = Cesium.Cartographic.fromCartesian(dropPosition);
        let currentHeight = initialCartographic.height;
        let localFallSpeed = 0;
        const terrainHeight = 0; // å¯æ›¿æ¢ä¸ºåœ°å½¢é«˜åº¦
        let lastTime = undefined; // âœ… å¿…é¡»å®šä¹‰å¹¶æ›´æ–°

        supplyEntity.position = new Cesium.CallbackProperty((time) => {
          // ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶ï¼Œè®°å½•æ—¶é—´
          if (!lastTime) {
            lastTime = Cesium.JulianDate.clone(time);
            return dropPosition; // è¿”å›åˆå§‹ä½ç½®
          }

          // è®¡ç®—æ—¶é—´å·®ï¼ˆç§’ï¼‰
          const deltaTime = Cesium.JulianDate.secondsDifference(time, lastTime);
          lastTime = Cesium.JulianDate.clone(time); // âœ… æ›´æ–° lastTime

          if (deltaTime > 0 && currentHeight > terrainHeight) {
            localFallSpeed += gravity * deltaTime;         // åŠ é€Ÿåº¦ï¼šé‡åŠ›
            currentHeight -= localFallSpeed * deltaTime;  // é«˜åº¦ä¸‹é™
            if (currentHeight < terrainHeight) {
              currentHeight = terrainHeight;
            }
          }

          // æ„é€ æ–°ä½ç½®ï¼ˆç»çº¬åº¦ä¸å˜ï¼Œé«˜åº¦ä¸‹é™ï¼‰
          const newPosition = Cesium.Cartesian3.fromRadians(
            initialCartographic.longitude,
            initialCartographic.latitude,
            currentHeight
          );

          // è½åœ°åå¯ä»¥æ‰“å°ä¸€æ¬¡ï¼ˆç”¨æ ‡å¿—ä½é¿å…é‡å¤ï¼‰
          if (currentHeight === terrainHeight && localFallSpeed > 0) {
            console.log("ğŸ“¦ ç‰©èµ„å·²è½åœ°ï¼");
            localFallSpeed = 0; // åœæ­¢é€Ÿåº¦
          }

          return newPosition;
        }, false); // false = ä¸æ˜¯å¸¸é‡ï¼Œä¼šå˜åŒ–
      }
    }, 100); // æ¯100msæ£€æŸ¥ä¸€æ¬¡

    // 2. åˆ›å»ºç©ºåŸŸéšœç¢ç‰©
    // åœ¨æ— äººæœºè·¯å¾„ä¸Šé€‰æ‹©ä¸€ä¸ªä¼šç¢°æ’çš„ç‚¹ï¼ˆä¾‹å¦‚ç¬¬ä¸‰ä¸ªèˆªç‚¹ï¼‰
    const collisionPoint = waypoints[2]; // { lon: 120.716, lat: 31.327, alt: 200 }

    // åˆ›å»ºä¸€å®šä¼šç¢°æ’çš„åœ†æŸ±ä½“ç¦é£åŒº
    // const noFlyZone = viewer.entities.add({
    //   name: "ç¦é£åŒº",
    //   position: Cesium.Cartesian3.fromDegrees(
    //     collisionPoint.lon,
    //     collisionPoint.lat,
    //     collisionPoint.alt
    //   ),
    //   cylinder: {
    //     length: 300,          // é«˜åº¦300ç±³ï¼ˆè¦†ç›–æ— äººæœºé£è¡Œé«˜åº¦ï¼‰
    //     topRadius: 0,         // é¡¶éƒ¨åŠå¾„ä¸º0ï¼ˆåœ†é”¥å½¢ï¼‰
    //     bottomRadius: 500,    // åº•éƒ¨åŠå¾„500ç±³ï¼ˆç¡®ä¿å®Œå…¨è¦†ç›–è·¯å¾„ï¼‰
    //     material: Cesium.Color.RED.withAlpha(0.3),
    //     outline: true,
    //     outlineColor: Cesium.Color.RED,
    //     outlineWidth: 2
    //   }
    // });

    const noFlyZoneEllipse = viewer.entities.add({
      name: "åœ†å½¢ç¦é£åŒº",
      customType: 'circle',
      position: Cesium.Cartesian3.fromDegrees(
        collisionPoint.lon,
        collisionPoint.lat,
        collisionPoint.alt
      ),
      ellipse: {  // ä½¿ç”¨æ¤­åœ†ï¼ˆåœ†å½¢ï¼‰è¡¨ç¤ºå¹³é¢ç¦é£åŒº
        semiMajorAxis: 500,  // åŠå¾„500ç±³ï¼ˆåœ†å½¢ï¼‰
        semiMinorAxis: 500,
        height: 0,          // å¹³é¢é«˜åº¦ä¸º0
        extrudedHeight: 0, // æ€»é«˜åº¦300ç±³ï¼ˆå½¢æˆæŸ±ä½“ï¼Œä½†ç¢°æ’æ£€æµ‹ä»…ç”¨å¹³é¢ï¼‰
        material: Cesium.Color.RED.withAlpha(0.3),
        outline: true,
        outlineColor: Cesium.Color.RED,
        outlineWidth: 2
      }
    });

    const noFlyZoneRectangle = viewer.entities.add({
      name: "çŸ©å½¢ç¦é£åŒº",
      customType: 'rectangle',
      position: Cesium.Cartesian3.fromDegrees(
        collisionPoint.lon + 0.015,
        collisionPoint.lat + 0.005,
        collisionPoint.alt
      ),

      rectangle: {
        coordinates: Cesium.Rectangle.fromDegrees(
          collisionPoint.lon + 0.010 - 0.005, // è¥¿ç»
          collisionPoint.lat + 0.010 - 0.005, // å—çº¬
          collisionPoint.lon + 0.010 + 0.005, // ä¸œç»
          collisionPoint.lat + 0.010 + 0.005  // åŒ—çº¬
        ),
        height: 0,
        extrudedHeight: 0,
        material: Cesium.Color.YELLOW.withAlpha(0.3)
      }
    });

    // 3. å¯ç”¨ç¢°æ’æ£€æµ‹
    dronePath.enableAirspaceCollisionDetection(
      [noFlyZoneRectangle],
      {
        warningDistance: 500,  // 100ç±³å¼€å§‹é¢„è­¦
        collisionDistance: 30  // 30ç±³åˆ¤å®šç¢°æ’
      }
    );

    // 4. ç›‘å¬ç¢°æ’äº‹ä»¶
    dronePath.onCollision = (drone, obstacle) => {
      console.log(`æ— äººæœºä¸ ${obstacle.name} å‘ç”Ÿç¢°æ’ï¼`);
      // å¯ä»¥æš‚åœåŠ¨ç”»ç­‰æ“ä½œ
      viewer.clock.shouldAnimate = false;
    };

    // await dronePath.createFlightPath(waypoints, viewer, {
    //   name: "æˆ‘çš„æ— äººæœº2",
    //   showPath: true,
    //   pathColor: Cesium.Color.YELLOW.withAlpha(0.7)
    // });

    // await dronePath.createFlightPath(waypoints, viewer, {
    //   name: "æˆ‘çš„æ— äººæœº3",
    //   showPath: true,
    //   pathColor: Cesium.Color.YELLOW.withAlpha(0.7)
    // });

    // æ·»åŠ ç©ºåŸŸ
    // dronePath.createAirspace('cylinder', {
    //   position: [120.716, 31.328],
    //   length: 500,
    //   radius: 2000,
    //   color: Cesium.Color.RED.withAlpha(0.3)
    // });
    // è®¾ç½®æ—¶é—´è½´
    // åŸºäºæ—¶é—´æ’å€¼ï¼šæ¯ä¸ªç‚¹é—´éš” 2 ç§’

  </script>
</body>



</html>