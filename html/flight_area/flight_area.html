<!DOCTYPE html>
<html lang="en">

<head>
  <script src="https://cdn.jsdelivr.net/npm/cesium@1.130/Build/Cesium/Cesium.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/cesium@1.130/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />
  <style>
    html,
    body,
    #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    #backButton {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 1000;
      padding: 10px 20px;
      background: rgba(48, 51, 56, 0.8);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      display: none;
    }

    #backButton:hover {
      background: rgba(48, 51, 56, 1);
    }

    #info {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 1000;
      background: rgba(48, 51, 56, 0.8);
      color: white;
      padding: 10px;
      border-radius: 4px;
      font-size: 12px;
      max-width: 300px;
    }

    #tooltip {
      position: absolute;
      background: rgba(48, 51, 56, 0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      /* ä¸å½±å“é¼ æ ‡ç©¿é€ */
      z-index: 1001;
      max-width: 200px;
      text-align: center;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.2);
      transform: translateY(-5px);
      /* å¾®è°ƒåŠ¨ç”»æ„Ÿ */
      transition: opacity 0.3s ease;
    }
  </style>
</head>

<body>
  <div id="cesiumContainer"></div>
  <button id="backButton" onclick="returnToMainScene()">è¿”å›ä¸»åœºæ™¯</button>

  <div id="info">
    <strong>æ“ä½œè¯´æ˜ï¼š</strong><br>
    â€¢ ç‚¹å‡»ä»»æ„èµ·é™åœºè¿›å…¥å­åœºæ™¯<br>
    â€¢ èµ·é™åœºç”±å¤šä¸ªçŸ©å½¢èµ·é™å•å…ƒç»„æˆ<br>
    â€¢ å­åœºæ™¯ä¸­å¯æŸ¥çœ‹èµ·é™å•å…ƒè¯¦æƒ…
  </div>
  <div id="tooltip" style="display: none;"></div>

  <script type="module">
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1OGIzZmQyZC03YjNiLTQzMjQtOWQxYS0xOTYxZWUyMTYzMjQiLCJpZCI6MzEzMjQxLCJpYXQiOjE3NTAyMjc2NDd9.G9X0WofFDt3mbp2L_WDzU__rcAVg0v3rpAliG1sgB9k';

    const terrainProvider = await Cesium.CesiumTerrainProvider.fromIonAssetId(1, {
      requestVertexNormals: true,
      requestWaterMask: true
    });

    const viewer = new Cesium.Viewer("cesiumContainer", {
      terrainProvider: terrainProvider,
      infoBox: false,
      selectionIndicator: false
    });

    // å…¨å±€å˜é‡
    let currentScene = 'main'; // 'main' æˆ– 'landing'
    let mainCameraPosition = null;
    let landingFields = [];
    let currentLandingField = null;

    // èµ·é™åœºæ•°æ® - æ›´æ–°ä¸ºæ–°åæ ‡ (119.998060, 30.282778)
    // èµ·é™åœºæ•°æ® - å·²æ•´ä½“å¹³ç§»åˆ°æ–°ä¸­å¿ƒ (119.995161825460514, 30.275375425493404)
    const landingFieldsData = [
      {
        id: 'field1',
        name: 'èµ·é™åœº A',
        center: Cesium.Cartesian3.fromDegrees(119.995161825460514, 30.275375425493404, 1),
        units: [
          { position: Cesium.Cartesian3.fromDegrees(119.99476182546051, 30.275675425493404, 2), width: 30, height: 40 },
          { position: Cesium.Cartesian3.fromDegrees(119.99526182546051, 30.275675425493404, 2), width: 30, height: 40 },
          { position: Cesium.Cartesian3.fromDegrees(119.99576182546051, 30.275675425493404, 2), width: 30, height: 40 },
          { position: Cesium.Cartesian3.fromDegrees(119.99476182546051, 30.275075425493404, 2), width: 30, height: 40 },
          { position: Cesium.Cartesian3.fromDegrees(119.99526182546051, 30.275075425493404, 2), width: 30, height: 40 },
          { position: Cesium.Cartesian3.fromDegrees(119.99576182546051, 30.275075425493404, 2), width: 30, height: 40 }
        ],
        weatherStations: [
          {
            id: 'ws1',
            name: 'æ°”è±¡ç«™ #1',
            position: Cesium.Cartesian3.fromDegrees(119.995161825460514, 30.275875425493404, 5), // åŒ—ä¾§ï¼Œç•¥é«˜äºåœ°é¢
            dimensions: new Cesium.Cartesian3(5, 5, 8), // é•¿å®½é«˜ï¼š5m x 5m x 8m
            data: {
              temperature: '26Â°C',
              humidity: '65%',
              windSpeed: '3.2 m/s',
              windDirection: 'NE',
              pressure: '1013 hPa',
              updateTime: '2025-04-05 10:30'
            }
          }
        ]
        // },
        // {
        //   id: 'field2',
        //   name: 'èµ·é™åœº B',
        //   center: Cesium.Cartesian3.fromDegrees(119.99616182546051, 30.276375425493404, 120),
        //   units: [
        //     { position: Cesium.Cartesian3.fromDegrees(119.99576182546051, 30.276675425493404, 120), width: 60, height: 40 },
        //     { position: Cesium.Cartesian3.fromDegrees(119.99656182546051, 30.276675425493404, 120), width: 60, height: 40 },
        //     { position: Cesium.Cartesian3.fromDegrees(119.99576182546051, 30.276075425493404, 120), width: 60, height: 40 },
        //     { position: Cesium.Cartesian3.fromDegrees(119.99656182546051, 30.276075425493404, 120), width: 60, height: 40 }
        //   ]
        // },
        // {
        //   id: 'field3',
        //   name: 'èµ·é™åœº C',
        //   center: Cesium.Cartesian3.fromDegrees(119.99416182546051, 30.274375425493404, 80),
        //   units: [
        //     { position: Cesium.Cartesian3.fromDegrees(119.99376182546051, 30.274675425493404, 80), width: 45, height: 25 },
        //     { position: Cesium.Cartesian3.fromDegrees(119.99456182546051, 30.274675425493404, 80), width: 45, height: 25 },
        //     { position: Cesium.Cartesian3.fromDegrees(119.99416182546051, 30.274075425493404, 80), width: 45, height: 25 }
        //   ]
      }
    ];
    // åˆ›å»ºèµ·é™åœº
    // åˆ›å»ºèµ·é™åœº
    function createLandingFields() {
      landingFieldsData.forEach(fieldData => {
        const landingField = {
          id: fieldData.id,
          name: fieldData.name,
          center: fieldData.center,
          units: [],
          boundaryEntity: null,
          baseEntity: null // ç”¨äºå­˜å‚¨åº•åº§å®ä½“
        };

        // === è®¡ç®—æ‰€æœ‰å•å…ƒçš„å¤–åŒ…çŸ©å½¢èŒƒå›´ï¼ˆWGS84 ç»çº¬åº¦ï¼‰===
        let west = Infinity, south = Infinity, east = -Infinity, north = -Infinity;

        fieldData.units.forEach(unitData => {
          const carto = Cesium.Cartographic.fromCartesian(unitData.position);
          const lat = Cesium.Math.toDegrees(carto.latitude);
          const lon = Cesium.Math.toDegrees(carto.longitude);

          const halfWidthDeg = (unitData.width / 111320) / 2; // ç±³è½¬çº¬åº¦/ç»åº¦è¿‘ä¼¼
          const halfHeightDeg = (unitData.height / 111320) / 2;

          const unitWest = lon - halfWidthDeg;
          const unitEast = lon + halfWidthDeg;
          const unitSouth = lat - halfHeightDeg;
          const unitNorth = lat + halfHeightDeg;

          west = Math.min(west, unitWest);
          east = Math.max(east, unitEast);
          south = Math.min(south, unitSouth);
          north = Math.max(north, unitNorth);
        });

        // æ‰©å¤§ä¸€ç‚¹ä½œä¸ºåº•åº§ï¼ˆæ¯”å¦‚å¤–æ‰© 10 ç±³ï¼‰
        const buffer = 10 / 111320; // 10ç±³ â‰ˆ 0.00009åº¦
        // === åˆ›å»ºåº•åº§å®ä½“ï¼ˆä½¿ç”¨ Polygon æ›¿ä»£ Rectangleï¼Œç¡®ä¿é«˜åº¦ç”Ÿæ•ˆï¼‰===
        const baseRectangle = Cesium.Rectangle.fromDegrees(
          west - buffer,
          south - buffer,
          east + buffer,
          north + buffer
        );

        // å°†çŸ©å½¢è½¬ä¸ºä¸–ç•Œåæ ‡ç‚¹æ•°ç»„ï¼ˆè¾¹ç•Œï¼‰
        const basePolygonHierarchy = Cesium.PolygonGeometry.fromPositions({
          positions: Cesium.Rectangle.subsample(baseRectangle, viewer.scene.globe.ellipsoid, 10), // é‡‡æ ·è¾¹ç•Œç‚¹
          height: 20, // åˆå§‹é«˜åº¦ï¼ˆå¯é€‰ï¼‰
          vertexFormat: Cesium.PerInstanceColorAppearance.VERTEX_FORMAT
        });

        // æå–è§’ç‚¹æ„é€  hierarchyï¼ˆæ›´é«˜æ•ˆï¼‰
        const corners = [
          Cesium.Cartesian3.fromRadians(baseRectangle.west, baseRectangle.south),
          Cesium.Cartesian3.fromRadians(baseRectangle.west, baseRectangle.north),
          Cesium.Cartesian3.fromRadians(baseRectangle.east, baseRectangle.north),
          Cesium.Cartesian3.fromRadians(baseRectangle.east, baseRectangle.south),
          Cesium.Cartesian3.fromRadians(baseRectangle.west, baseRectangle.south) // é—­åˆ
        ];

        const baseEntity = viewer.entities.add({
          id: `${fieldData.id}_base`,
          polygon: {
            hierarchy: new Cesium.PolygonHierarchy(corners),
            material: new Cesium.ImageMaterialProperty({
              image: 'image.png',
              repeat: new Cesium.Cartesian2(1, 1),
              color: Cesium.Color.WHITE.withAlpha(0.9),
              transparent: true
            }),
            outline: true,
            outlineColor: Cesium.Color.WHITE.withAlpha(0.6),
            outlineWidth: 2,
            // âœ… å…³é”®ï¼šä½¿ç”¨ç›¸å¯¹åœ°é¢é«˜åº¦
            heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
            extrudedHeight: 0.1, // æŠ¬å‡ä¸€ç‚¹ç‚¹é˜²æ­¢ç©¿æ¨¡ï¼ˆå¦‚ 0.1 ç±³ï¼‰
            extrudedHeightReference: Cesium.HeightReference.RELATIVE_TO_GROUND
          },
          position: fieldData.center, // å¯é€‰ï¼Œç”¨äºå®šä¹‰å±€éƒ¨åæ ‡ç³»åŸç‚¹
          properties: {
            type: 'landingBase',
            fieldId: fieldData.id
          }
        });

        landingField.baseEntity = baseEntity;

        // === åˆ›å»ºèµ·é™å•å…ƒï¼ˆåŸæœ‰é€»è¾‘ï¼‰===
        fieldData.units.forEach((unitData, index) => {
          const cartographic = Cesium.Cartographic.fromCartesian(unitData.position);
          const longitude = cartographic.longitude;
          const latitude = cartographic.latitude;
          const height = cartographic.height;

          const halfWidthRad = Cesium.Math.toRadians(unitData.width / 111320 / 2);
          const halfHeightRad = Cesium.Math.toRadians(unitData.height / 111320 / 2);

          const west = longitude - halfWidthRad;
          const east = longitude + halfWidthRad;
          const south = latitude - halfHeightRad;
          const north = latitude + halfHeightRad;

          // ğŸ‘‡ åˆ›å»ºçŸ©å½¢å››ä¸ªè§’ç‚¹ï¼ˆå¸¦é«˜åº¦ï¼‰
          const corners = [
            Cesium.Cartesian3.fromRadians(west, south, height + 0.11), // å·¦ä¸‹
            Cesium.Cartesian3.fromRadians(west, north, height + 0.11), // å·¦ä¸Š
            Cesium.Cartesian3.fromRadians(east, north, height + 0.11), // å³ä¸Š
            Cesium.Cartesian3.fromRadians(east, south, height + 0.11), // å³ä¸‹
            Cesium.Cartesian3.fromRadians(west, south, height + 0.11)  // é—­åˆ
          ];

          const unit = viewer.entities.add({
            id: `${fieldData.id}_unit_${index}`,
            polygon: {
              hierarchy: corners,
              material: new Cesium.ImageMaterialProperty({
                image: 'runway.png',
                repeat: new Cesium.Cartesian2(1, 1),
                color: Cesium.Color.WHITE,
                transparent: true
              }),
              outline: true,
              outlineColor: Cesium.Color.BLUE,
              outlineWidth: 2,
              heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
              extrudedHeight: 1.5, // é«˜åº¦åšåº¦
              extrudedHeightReference: Cesium.HeightReference.RELATIVE_TO_GROUND
            },
            properties: {
              type: 'landingUnit',
              fieldId: fieldData.id,
              fieldName: fieldData.name,
              unitIndex: index,
              width: unitData.width,
              height: unitData.height
            }
          });

          // âœ… å†å•ç‹¬æ·»åŠ ä¸€ä¸ª labelï¼Œæ”¾åœ¨çŸ©å½¢ä¸­å¿ƒ
          const labelEntity = viewer.entities.add({
            position: unitData.position,
            label: {
              text: '#' + (index + 1).toString(),
              font: '14pt bold sans-serif',
              fillColor: Cesium.Color.WHITE,
              outlineColor: Cesium.Color.BLACK,
              outlineWidth: 3,
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
              horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
              pixelOffset: new Cesium.Cartesian2(0, -10),
              heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
              disableDepthTestDistance: Number.POSITIVE_INFINITY // é˜²æ­¢è¢«é®æŒ¡
            },
            properties: {
              type: 'landingUnitLabel',
              fieldId: fieldData.id,
              unitIndex: index
            }
          });



          landingField.units.push(unit);
        });

        if (fieldData.weatherStations && fieldData.weatherStations.length > 0) {
          landingField.weatherStations = []; // åˆå§‹åŒ–æ•°ç»„

          fieldData.weatherStations.forEach(ws => {
            const wsEntity = viewer.entities.add({
              id: `${fieldData.id}_weather_${ws.id}`,
              position: Cesium.Cartesian3.fromDegrees(119.995161825460514, 30.275875425493404, 0.1), // ğŸ‘ˆ åŒ¹é…åº•åº§é«˜åº¦
              box: {
                dimensions: ws.dimensions,
                material: new Cesium.ImageMaterialProperty({
                  image: 'runway.png',
                  repeat: new Cesium.Cartesian2(1, 1),
                  color: Cesium.Color.WHITE,
                  transparent: true
                }),
                //material: Cesium.Color.WHITE.withAlpha(0.8),
                outline: true,
                outlineColor: Cesium.Color.CYAN,
                outlineWidth: 2,
                heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND
              },
              label: {
                text: ws.name,
                font: '12pt sans-serif',
                fillColor: Cesium.Color.WHITE,
                outlineColor: Cesium.Color.BLACK,
                outlineWidth: 2,
                style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                pixelOffset: new Cesium.Cartesian2(0, -6),
                heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND,
                disableDepthTestDistance: Number.POSITIVE_INFINITY // ğŸ‘ˆ å…³é”®ï¼å¼ºåˆ¶æ˜¾ç¤º
              },
              properties: {
                type: 'weatherStation',
                fieldId: fieldData.id,
                stationId: ws.id,
                name: ws.name,
                data: ws.data
              }
            });

            landingField.weatherStations.push(wsEntity);
          });
        }
        // === åˆ›å»ºèµ·é™åœºè¾¹ç•Œæ ‡è¯†ï¼ˆåŸæœ‰é€»è¾‘ï¼‰===
        const boundary = viewer.entities.add({
          id: `${fieldData.id}_boundary`,
          position: fieldData.center,
          label: {
            text: fieldData.name,
            font: '16pt sans-serif',
            fillColor: Cesium.Color.YELLOW,
            outlineColor: Cesium.Color.BLACK,
            outlineWidth: 2,
            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
            pixelOffset: new Cesium.Cartesian2(0, -50),
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
          },
          point: {
            pixelSize: 15,
            color: Cesium.Color.YELLOW,
            outlineColor: Cesium.Color.BLACK,
            outlineWidth: 2,
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
          },
          properties: {
            type: 'landingField',
            fieldId: fieldData.id,
            fieldName: fieldData.name
          }
        });

        landingField.boundaryEntity = boundary;
        landingFields.push(landingField);
      });
    }
    // è¿›å…¥èµ·é™åœºå­åœºæ™¯
    function enterLandingFieldScene(fieldId) {
      currentScene = 'landing';
      const field = landingFields.find(f => f.id === fieldId);
      if (!field) return;

      currentLandingField = field;

      // ä¿å­˜ä¸»åœºæ™¯æ‘„åƒå¤´ä½ç½®
      mainCameraPosition = {
        destination: viewer.camera.position.clone(),
        orientation: {
          heading: viewer.camera.heading,
          pitch: viewer.camera.pitch,
          roll: viewer.camera.roll
        }
      };

      // éšè—å…¶ä»–èµ·é™åœº
      landingFields.forEach(otherField => {
        if (otherField.id !== fieldId) {
          otherField.boundaryEntity.show = false;
          otherField.units.forEach(unit => unit.show = false);
        }
      });

      // é£è¡Œåˆ°å½“å‰èµ·é™åœº
      viewer.camera.flyTo({
        destination: Cesium.Cartesian3.fromDegrees(
          Cesium.Math.toDegrees(Cesium.Cartographic.fromCartesian(field.center).longitude),
          Cesium.Math.toDegrees(Cesium.Cartographic.fromCartesian(field.center).latitude),
          200
        ),
        orientation: {
          heading: 0,
          pitch: Cesium.Math.toRadians(-70),
          roll: 0
        },
        duration: 2.0
      });

      // æ˜¾ç¤ºè¿”å›æŒ‰é’®
      document.getElementById('backButton').style.display = 'block';

      // æ›´æ–°ä¿¡æ¯é¢æ¿
      document.getElementById('info').innerHTML = `
        <strong>${field.name} è¯¦æƒ…ï¼š</strong><br>
        â€¢ èµ·é™å•å…ƒæ•°é‡: ${field.units.length}<br>
        â€¢ åœºåœ°ä½ç½®: ${Cesium.Math.toDegrees(Cesium.Cartographic.fromCartesian(field.center).longitude).toFixed(4)}Â°, 
        ${Cesium.Math.toDegrees(Cesium.Cartographic.fromCartesian(field.center).latitude).toFixed(4)}Â°<br>
        â€¢ ç‚¹å‡»èµ·é™å•å…ƒæŸ¥çœ‹è¯¦æƒ…
      `;
    }

    // è¿”å›ä¸»åœºæ™¯
    window.returnToMainScene = function () {
      currentScene = 'main';
      currentLandingField = null;

      // æ˜¾ç¤ºæ‰€æœ‰èµ·é™åœº
      landingFields.forEach(field => {
        field.boundaryEntity.show = true;
        field.units.forEach(unit => unit.show = true);
      });

      // æ¢å¤æ‘„åƒå¤´ä½ç½®
      if (mainCameraPosition) {
        viewer.camera.flyTo({
          destination: mainCameraPosition.destination,
          orientation: mainCameraPosition.orientation,
          duration: 2.0
        });
      }

      // éšè—è¿”å›æŒ‰é’®
      document.getElementById('backButton').style.display = 'none';

      // æ¢å¤ä¿¡æ¯é¢æ¿
      document.getElementById('info').innerHTML = `
        <strong>æ“ä½œè¯´æ˜ï¼š</strong><br>
        â€¢ ç‚¹å‡»ä»»æ„èµ·é™åœºè¿›å…¥å­åœºæ™¯<br>
        â€¢ èµ·é™åœºç”±å¤šä¸ªçŸ©å½¢èµ·é™å•å…ƒç»„æˆ<br>
        â€¢ å­åœºæ™¯ä¸­å¯æŸ¥çœ‹èµ·é™å•å…ƒè¯¦æƒ…
      `;
    };

    // ç‚¹å‡»äº‹ä»¶å¤„ç†
    // åŠ¨æ€æç¤ºæ¡†å…ƒç´ 
    const tooltip = document.getElementById('tooltip');

    const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);

    // å·¦é”®ç‚¹å‡»ï¼šå°è¯•æ·»åŠ èˆªç‚¹ï¼ˆæ’å…¥æˆ–è¿½åŠ ï¼‰
    handler.setInputAction((click) => {

      const pickedObject = viewer.scene.pick(click.position);

      // æ¸…é™¤ä¹‹å‰çš„ tooltip æ˜¾ç¤º
      tooltip.style.display = 'none';

      if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.id)) {
        const entity = pickedObject.id;
        const properties = entity.properties;

        if (properties && properties.type) {
          if (properties.type._value === 'landingField' && currentScene === 'main') {
            enterLandingFieldScene(properties.fieldId._value);
          }
          else if (properties.type._value === 'landingUnit' && currentScene === 'landing') {
            const unitIndex = properties.unitIndex._value;
            const fieldName = properties.fieldName._value;
            const width = properties.width._value;
            const height = properties.height._value;

            // è®¾ç½® tooltip å†…å®¹
            tooltip.innerHTML = `
            <strong>å•å…ƒ #${unitIndex + 1}</strong><br>
            ${width}m Ã— ${height}m<br>
            çŠ¶æ€: å¯ç”¨
          `;

            // è·å–è¯¥èµ·é™å•å…ƒä¸­å¿ƒçš„ä¸–ç•Œåæ ‡ï¼ˆå³ entity.positionï¼‰
            // âœ… è·å– polygon ä¸­å¿ƒç‚¹
            const positions = entity.polygon.hierarchy.getValue(viewer.clock.currentTime).positions;
            const boundingSphere = Cesium.BoundingSphere.fromPoints(positions);
            const position = boundingSphere.center;

            // è½¬æ¢ä¸ºå±å¹•åæ ‡
            const screenPosition = viewer.scene.cartesianToCanvasCoordinates(position);

            if (Cesium.defined(screenPosition)) {
              // è®¾ç½® tooltip ä½ç½®ï¼ˆç•¥é«˜äºä¸­å¿ƒï¼‰
              tooltip.style.left = `${screenPosition.x}px`;
              tooltip.style.top = `${screenPosition.y - 40}px`; // ä¸Šæ–¹åç§» 40px
              tooltip.style.display = 'block';
            }

            // âœ…âœ…âœ… å…³é”®ä¿®å¤ï¼šä» position æå–ç»çº¬é«˜
            const cartographic = Cesium.Cartographic.fromCartesian(position);
            const lon = Cesium.Math.toDegrees(cartographic.longitude);
            const lat = Cesium.Math.toDegrees(cartographic.latitude);
            const alt = cartographic.height;

            // âœ… é£è¡Œåˆ°å•å…ƒä¸Šæ–¹ï¼Œä¾¿äºè§‚å¯Ÿ
            // viewer.camera.flyTo({
            //   destination: Cesium.Cartesian3.fromDegrees(lon, lat, alt + 100), // ä¸Šæ–¹50ç±³
            //   orientation: {
            //     heading: viewer.camera.heading, // ä¿æŒå½“å‰æ–¹å‘ï¼ˆæˆ–è®¾ä¸º0æœåŒ—ï¼‰
            //     pitch: Cesium.Math.toRadians(-90), // ä¿¯è§†45åº¦
            //     roll: 0
            //   },
            //   duration: 1.5
            // });
            // åŒæ—¶ä¹Ÿå¯ä»¥é«˜äº®æè´¨
            // âœ… é«˜äº® polygon æˆ– rectangle
            if (entity.polygon) {
              const originalMaterial = entity.polygon.material;
              entity.polygon.material = Cesium.Color.ORANGE.withAlpha(0.8);

              setTimeout(() => {
                entity.polygon.material = originalMaterial;
                tooltip.style.display = 'none';
              }, 2000);
            } else if (entity.rectangle) {
              const originalMaterial = entity.rectangle.material;
              entity.rectangle.material = Cesium.Color.ORANGE.withAlpha(0.8);

              setTimeout(() => {
                entity.rectangle.material = originalMaterial;
                tooltip.style.display = 'none';
              }, 2000);
            }

            // æ›´æ–°å³ä¸Šè§’ info é¢æ¿ï¼ˆå¯é€‰ä¿ç•™ï¼‰
            document.getElementById('info').innerHTML = `
            <strong>èµ·é™å•å…ƒè¯¦æƒ…ï¼š</strong><br>
            â€¢ æ‰€å±åœºåœ°: ${fieldName}<br>
            â€¢ å•å…ƒç¼–å·: ${unitIndex + 1}<br>
            â€¢ å°ºå¯¸: ${width}m Ã— ${height}m<br>
            â€¢ çŠ¶æ€: å¯ç”¨
           `;
          }
          else if (properties.type._value === 'weatherStation' && currentScene === 'landing') {
            const stationName = properties.name._value;
            const data = properties.data._value;

            tooltip.innerHTML = `
            <strong>${stationName}</strong><br>
            æ¸©åº¦: ${data.temperature}<br>
            æ¹¿åº¦: ${data.humidity}<br>
            é£é€Ÿ: ${data.windSpeed}<br>
            é£å‘: ${data.windDirection}<br>
            æ°”å‹: ${data.pressure}<br>
            æ›´æ–°: ${data.updateTime}
          `;

            const position = entity.position.getValue(viewer.clock.currentTime);
            const screenPosition = viewer.scene.cartesianToCanvasCoordinates(position);

            if (Cesium.defined(screenPosition)) {
              tooltip.style.left = `${screenPosition.x}px`;
              tooltip.style.top = `${screenPosition.y - 60}px`;
              tooltip.style.display = 'block';
            }


            // âœ… åªé«˜äº®å˜è‰²ï¼Œä¸æ”¹å˜å°ºå¯¸
            //const originalMaterial = entity.box.material;
            //entity.box.material = Cesium.Color.YELLOW.withAlpha(0.9);

            setTimeout(() => {
              // entity.box.material = originalMaterial;
              tooltip.style.display = 'none';
            }, 1000);

            // æ›´æ–° info é¢æ¿
            const carto = Cesium.Cartographic.fromCartesian(position);
            document.getElementById('info').innerHTML = `
              <strong>æ°”è±¡ç«™è¯¦æƒ…ï¼š</strong><br>
              â€¢ åç§°: ${stationName}<br>
              â€¢ ä½ç½®: ${Cesium.Math.toDegrees(carto.longitude).toFixed(4)}Â°, 
              ${Cesium.Math.toDegrees(carto.latitude).toFixed(4)}Â°<br>
              â€¢ ç‚¹å‡»æŸ¥çœ‹å®æ—¶æ°”è±¡æ•°æ®
            `;
          }
        }
      }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
    // åŠ è½½ 3D Tileset (å¦‚æœå¯ç”¨)
    try {
      const tileset = viewer.scene.primitives.add(
        await Cesium.Cesium3DTileset.fromUrl(
          "https://gl.hangzhoudk.com/modelfile/tileset.json",
          { debugShowBoundingVolume: false }
        )
      );

      // åˆå§‹è§†å›¾èšç„¦åˆ°tilesetï¼Œç„¶ååˆ›å»ºèµ·é™åœº
      await viewer.zoomTo(tileset);
      createLandingFields();
    } catch (error) {
      console.log("æ— æ³•åŠ è½½3D Tilesetï¼Œä½¿ç”¨é»˜è®¤è§†å›¾");
      // å¦‚æœæ— æ³•åŠ è½½tilesetï¼Œè®¾ç½®é»˜è®¤è§†å›¾åˆ°æ–°åæ ‡
      viewer.camera.setView({
        destination: Cesium.Cartesian3.fromDegrees(119.998060, 30.282778, 2000),
        orientation: {
          heading: 0,
          pitch: Cesium.Math.toRadians(-30),
          roll: 0
        }
      });
      createLandingFields();
    }

  </script>
</body>

</html>