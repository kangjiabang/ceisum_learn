<!DOCTYPE html>
<html lang="en">

<head>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.130/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.130/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    html,
    body,
    #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <div id="cesiumContainer"></div>
  <script type="module">
    // Your access token can be found at: https://ion.cesium.com/tokens.  
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1OGIzZmQyZC03YjNiLTQzMjQtOWQxYS0xOTYxZWUyMTYzMjQiLCJpZCI6MzEzMjQxLCJpYXQiOjE3NTAyMjc2NDd9.G9X0WofFDt3mbp2L_WDzU__rcAVg0v3rpAliG1sgB9k';

    // å…ˆåˆ›å»ºåœ°å½¢æä¾›è€…
    const terrainProvider = await Cesium.CesiumTerrainProvider.fromIonAssetId(1, {
      requestVertexNormals: true,
      requestWaterMask: true
    });

    const viewer = new Cesium.Viewer("cesiumContainer", {
      shouldDebug: true,
      terrainProvider: terrainProvider
    });

    // å­˜å‚¨åˆ›å»ºçš„å®ä½“
    let droneEntity = null;
    let rayEntities = [];

    //åŠ è½½ 3D Tilesetï¼ˆè‡ªåŠ¨è§£æ B3DMï¼‰
    const tileset = viewer.scene.primitives.add(
      await Cesium.Cesium3DTileset.fromUrl(
        "http://192.168.4.78:8000/tileset.json",
        {
          debugShowBoundingVolume: true,
        })
    );

    tileset.loadProgress.addEventListener((numberOfPendingRequests) => {
      console.log(`æ­£åœ¨åŠ è½½: ${numberOfPendingRequests} ä¸ªè¯·æ±‚`);
    });

    // å®šä½åˆ° Tileset
    viewer.zoomTo(tileset);

    // ç”Ÿæˆå‚ç›´å‘ä¸‹çš„å°„çº¿æ–¹å‘ï¼ˆå±€éƒ¨åæ ‡ç³»ï¼‰
    function getLocalDownDirection(position) {
      // è·å–ä½ç½®çš„å±€éƒ¨ä¸œåŒ—å¤©(ENU)åæ ‡ç³»
      const enuMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);

      // ä»ENUçŸ©é˜µä¸­æå–"ä¸‹"æ–¹å‘ï¼ˆENUä¸­çš„Downæ˜¯-Zè½´ï¼‰
      const downDirection = new Cesium.Cartesian3();
      Cesium.Matrix4.multiplyByPointAsVector(
        enuMatrix,
        new Cesium.Cartesian3(0, 0, -1),
        downDirection
      );

      Cesium.Cartesian3.normalize(downDirection, downDirection);
      return downDirection;
    }

    // ç”Ÿæˆé”¥å½¢åˆ†å¸ƒçš„å°„çº¿
    function generateConeRays(origin, rayCount = 12, coneAngle = 30) {
      const rays = [];

      // è·å–å±€éƒ¨åæ ‡ç³»çš„"ä¸‹"æ–¹å‘
      const localDown = getLocalDownDirection(origin);

      // è·å–å±€éƒ¨åæ ‡ç³»çš„å˜æ¢çŸ©é˜µ
      const enuMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);
      const inverseEnuMatrix = Cesium.Matrix4.inverse(enuMatrix, new Cesium.Matrix4());

      if (rayCount === 1) {
        // åªç”Ÿæˆä¸€ä¸ªå‚ç›´å‘ä¸‹çš„å°„çº¿
        rays.push({
          direction: localDown,
          isCenterRay: true
        });
        return rays;
      }

      // ç”Ÿæˆé”¥å½¢å°„çº¿
      for (let i = 0; i < rayCount; i++) {
        if (i === 0) {
          // ä¸­å¿ƒå°„çº¿ï¼šå‚ç›´å‘ä¸‹
          rays.push({
            direction: localDown,
            horizontalAngle: 0,
            verticalAngle: 0,
            isCenterRay: true
          });
        } else {
          // é”¥å½¢å‘¨å›´çš„å°„çº¿
          const surroundingRays = rayCount - 1;
          const index = i - 1;

          const horizontalAngle = (index / surroundingRays) * 2 * Math.PI;
          const coneAngleRad = Cesium.Math.toRadians(coneAngle);

          // åœ¨å±€éƒ¨ENUåæ ‡ç³»ä¸­è®¡ç®—æ–¹å‘
          const x = Math.sin(coneAngleRad) * Math.cos(horizontalAngle); // ä¸œå‘åˆ†é‡
          const y = Math.sin(coneAngleRad) * Math.sin(horizontalAngle); // åŒ—å‘åˆ†é‡
          const z = -Math.cos(coneAngleRad); // ä¸‹å‘åˆ†é‡ï¼ˆè´Ÿå·è¡¨ç¤ºå‘ä¸‹ï¼‰

          // è½¬æ¢åˆ°ä¸–ç•Œåæ ‡ç³»
          const localDirection = new Cesium.Cartesian3(x, y, z);
          const worldDirection = new Cesium.Cartesian3();

          Cesium.Matrix4.multiplyByPointAsVector(enuMatrix, localDirection, worldDirection);
          Cesium.Cartesian3.normalize(worldDirection, worldDirection);

          rays.push({
            direction: worldDirection,
            horizontalAngle: Cesium.Math.toDegrees(horizontalAngle),
            verticalAngle: coneAngle,
            isCenterRay: false
          });
        }
      }

      return rays;
    }

    viewer.canvas.addEventListener('click', async (event) => {
      try {
        // æ¸…é™¤ä¹‹å‰çš„æ— äººæœºå’Œå°„çº¿
        if (droneEntity) {
          viewer.entities.remove(droneEntity);
          droneEntity = null;
        }

        // æ¸…é™¤ä¹‹å‰çš„å°„çº¿å®ä½“
        rayEntities.forEach(entity => {
          viewer.entities.remove(entity);
        });
        rayEntities = [];

        // ä½¿ç”¨å›ºå®šçš„å»ºç­‘ç‰©ä¸­å¿ƒç‚¹åæ ‡
        const longitude_click = 119.9980574;
        const latitude_click = 30.28275965;


        const height_click = 300;

        console.log("ç‚¹å‡»åæ ‡ï¼ˆç»çº¬åº¦ï¼‰:", { longitude_click, latitude_click, height_click });

        // è·å–åœ°å½¢é«˜åº¦
        const terrainSample = await Cesium.sampleTerrainMostDetailed(
          viewer.terrainProvider,
          [new Cesium.Cartographic(
            Cesium.Math.toRadians(longitude_click),
            Cesium.Math.toRadians(latitude_click)
          )]
        );

        if (!terrainSample || terrainSample.length === 0) {
          console.error("æ— æ³•è·å–åœ°å½¢é«˜åº¦");
          return;
        }

        // è·å–åœ°å½¢é«˜åº¦
        const terrainHeight = terrainSample[0].height;
        console.log("åœ°å½¢é«˜åº¦:", terrainHeight.toFixed(2), "ç±³");

        // åˆ›å»ºæ— äººæœºä½ç½®
        const dronePositionCartesian = Cesium.Cartesian3.fromDegrees(
          longitude_click,
          latitude_click,
          height_click
        );

        // è·å–æ— äººæœºæ¨¡å‹
        const airplaneUri = await Cesium.IonResource.fromAssetId(3472138);

        const heading = Cesium.Math.toRadians(-90); // æ°´å¹³æ–¹å‘åè½¬90åº¦
        const pitch = Cesium.Math.toRadians(0);    // ä¿¯ä»°è§’ 0 åº¦
        const roll = Cesium.Math.toRadians(0);     // æ»šè½¬è§’ 0 åº¦

        const hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
        const orientation = Cesium.Transforms.headingPitchRollQuaternion(
          dronePositionCartesian,
          hpr
        );

        // åˆ›å»ºæ–°çš„æ— äººæœºå®ä½“
        droneEntity = viewer.entities.add({
          name: "æ— äººæœº",
          position: dronePositionCartesian,
          orientation: orientation,
          model: {
            uri: airplaneUri,
            scale: 5.0,
            minimumPixelSize: 64
          }
        });

        // è§†è§’èšç„¦åˆ°æ— äººæœº
        viewer.zoomTo(droneEntity, new Cesium.HeadingPitchRange(
          Cesium.Math.toRadians(-90),
          Cesium.Math.toRadians(-15),
          2000
        ));

        // ç”Ÿæˆé”¥å½¢å°„çº¿ï¼ˆå‚ç›´å‘ä¸‹ä¸ºä¸­å¿ƒï¼‰
        const coneRays = generateConeRays(dronePositionCartesian, 6, 1); // 9æ¡å°„çº¿ï¼Œ45åº¦é”¥å½¢è§’

        let collisionDetected = false;

        // å¤„ç†æ¯æ¡å°„çº¿
        coneRays.forEach((rayInfo, rayIndex) => {
          const ray = new Cesium.Ray(dronePositionCartesian, rayInfo.direction);

          // å¯è§†åŒ–å°„çº¿
          const rayEntity = viewer.entities.add({
            name: `å°„çº¿_${rayIndex}`,
            polyline: {
              positions: [
                dronePositionCartesian,
                Cesium.Cartesian3.add(
                  dronePositionCartesian,
                  Cesium.Cartesian3.multiplyByScalar(
                    rayInfo.direction,
                    500, // å°„çº¿é•¿åº¦
                    new Cesium.Cartesian3()
                  ),
                  new Cesium.Cartesian3()
                )
              ],
              width: rayInfo.isCenterRay ? 3 : 2,
              material: rayInfo.isCenterRay ?
                new Cesium.PolylineOutlineMaterialProperty({
                  color: Cesium.Color.RED,
                  outlineColor: Cesium.Color.BLACK,
                  outlineWidth: 1
                }) :
                new Cesium.PolylineGlowMaterialProperty({
                  color: Cesium.Color.BLUE.withAlpha(0.7),
                  glowPower: 0.1
                })
            }
          });
          rayEntities.push(rayEntity);

          // å°„çº¿æ£€æµ‹
          const hitPoint = viewer.scene.pickFromRay(ray);
          if (!hitPoint) {
            console.log(`âŒ å°„çº¿${rayIndex}æœªç©¿è¿‡ä»»ä½•ç‰©ä½“`);
            return;
          }

          if (hitPoint.position) {
            const cartographicHit = Cesium.Cartographic.fromCartesian(hitPoint.position);
            const distance = Cesium.Cartesian3.distance(dronePositionCartesian, hitPoint.position);

            // è®¡ç®—å»ºç­‘ç‰©é«˜åº¦
            const buildingHeight = Math.max(0, cartographicHit.height - terrainHeight);

            console.log(
              `ğŸ“ å°„çº¿${rayIndex}ç¢°æ’ç‚¹: ç»åº¦=${Cesium.Math.toDegrees(cartographicHit.longitude).toFixed(6)}, ` +
              `çº¬åº¦=${Cesium.Math.toDegrees(cartographicHit.latitude).toFixed(6)}, ` +
              `åœ°å½¢é«˜åº¦=${terrainHeight.toFixed(2)}ç±³, ` +
              `ç¢°æ’ç‚¹é«˜åº¦=${cartographicHit.height.toFixed(2)}ç±³, ` +
              `å»ºç­‘ç‰©é«˜åº¦=${buildingHeight.toFixed(2)}ç±³, ` +
              `è·ç¦»=${distance.toFixed(2)}ç±³`
            );

            if (distance < 500) { // æ‰©å¤§æ£€æµ‹èŒƒå›´
              console.log(`ğŸ¨ å°„çº¿${rayIndex}æ£€æµ‹åˆ°è¿‘è·ç¦»ç‰©ä½“`);

              // å¯è§†åŒ–å‘½ä¸­ç‚¹
              const hitEntity = viewer.entities.add({
                name: `ç¢°æ’ç‚¹_${rayIndex}`,
                position: hitPoint.position,
                point: {
                  pixelSize: rayInfo.isCenterRay ? 30 : 20,
                  color: distance < 100 ? Cesium.Color.RED :
                    distance < 200 ? Cesium.Color.ORANGE : Cesium.Color.YELLOW,
                  outlineColor: Cesium.Color.WHITE,
                  outlineWidth: 2
                },
                label: {
                  text: `é«˜åº¦: ${buildingHeight.toFixed(1)}m\nè·ç¦»: ${distance.toFixed(1)}m`,
                  font: '12px sans-serif',
                  fillColor: Cesium.Color.WHITE,
                  outlineColor: Cesium.Color.BLACK,
                  outlineWidth: 2,
                  style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                  pixelOffset: new Cesium.Cartesian2(0, -30)
                }
              });
              rayEntities.push(hitEntity);

              collisionDetected = true;
            } else {
              console.log(`âš ï¸ å°„çº¿${rayIndex}è·ç¦»å¤§äº500mï¼Œè·³è¿‡`);
            }
          }
        });

        if (!collisionDetected) {
          console.log("âœ… æœªæ£€æµ‹åˆ°è¿‘è·ç¦»éšœç¢ç‰©");
        }

      } catch (error) {
        console.error("å¤„ç†è¿‡ç¨‹ä¸­å‡ºé”™:", error);
      }
    });
  </script>
</body>

</html>