<!DOCTYPE html>
<html lang="en">

<head>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.130/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.130/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    html,
    body,
    #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <div id="cesiumContainer"></div>
  <script type="module">
    // Your access token can be found at: https://ion.cesium.com/tokens.  
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1OGIzZmQyZC03YjNiLTQzMjQtOWQxYS0xOTYxZWUyMTYzMjQiLCJpZCI6MzEzMjQxLCJpYXQiOjE3NTAyMjc2NDd9.G9X0WofFDt3mbp2L_WDzU__rcAVg0v3rpAliG1sgB9k';

    // 先创建地形提供者
    const terrainProvider = await Cesium.CesiumTerrainProvider.fromIonAssetId(1, {
      requestVertexNormals: true,
      requestWaterMask: true
    });

    const viewer = new Cesium.Viewer("cesiumContainer", {
      shouldDebug: true,
      terrainProvider: terrainProvider
    });


    //加载 3D Tileset（自动解析 B3DM）
    const tileset = viewer.scene.primitives.add(
      await Cesium.Cesium3DTileset.fromUrl(
        "http://192.168.4.78:8000/tileset.json",
        {
          debugShowBoundingVolume: true,
        })
    );

    tileset.loadProgress.addEventListener((numberOfPendingRequests) => {
      console.log(`正在加载: ${numberOfPendingRequests} 个请求`);
    });

    // 定位到 Tileset
    viewer.zoomTo(tileset);
    const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);
    let droneEntity = null;
    let rayEntities = [];
    let detectionIntervalId = null;

    // 无人机航线（经纬度+高度）
    const waypoints = [
      { lon: 119.9980574, lat: 30.28275965, height: 100 },
      { lon: 120.0005, lat: 30.2832, height: 100 },
      { lon: 120.0020, lat: 30.2840, height: 100 },
      { lon: 120.0040, lat: 30.2850, height: 100 },
      { lon: 120.0060, lat: 30.2860, height: 100 },
      { lon: 120.0080, lat: 30.2880, height: 100 },
      { lon: 120.0100, lat: 30.2900, height: 100 }
    ];

    (async function initDroneFlight() {
      try {
        // 构建航迹
        const positionProperty = new Cesium.SampledPositionProperty();
        let startTime = Cesium.JulianDate.now();
        let timeStep = 10; // 每段航点的飞行时间（秒）

        for (let i = 0; i < waypoints.length; i++) {
          const wp = waypoints[i];
          const terrainSample = await Cesium.sampleTerrainMostDetailed(
            viewer.terrainProvider,
            [new Cesium.Cartographic(
              Cesium.Math.toRadians(wp.lon),
              Cesium.Math.toRadians(wp.lat)
            )]
          );
          const terrainHeight = terrainSample[0].height;

          const pos = Cesium.Cartesian3.fromDegrees(wp.lon, wp.lat, wp.height);
          const time = Cesium.JulianDate.addSeconds(startTime, i * timeStep, new Cesium.JulianDate());
          positionProperty.addSample(time, pos);
        }

        // 设置飞行时间范围
        const totalTime = timeStep * (waypoints.length - 1);
        viewer.clock.startTime = startTime.clone();
        viewer.clock.stopTime = Cesium.JulianDate.addSeconds(startTime, totalTime, new Cesium.JulianDate());
        viewer.clock.currentTime = startTime.clone();
        viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP; // 循环
        viewer.clock.multiplier = 1 * 0.5; // 时间倍率


        // 无人机模型
        droneEntity = viewer.entities.add({
          availability: new Cesium.TimeIntervalCollection([new Cesium.TimeInterval({
            start: viewer.clock.startTime,
            stop: viewer.clock.stopTime
          })]),
          position: positionProperty,
          orientation: new Cesium.VelocityOrientationProperty(positionProperty),
          model: {
            uri: "models/drone_costum.glb",
            scale: 5.0,
            minimumPixelSize: 64,
            allowPicking: false // 关键
          }
        });




        viewer.clock.shouldAnimate = true; // 启动时间动画
        viewer.trackedEntity = droneEntity; // 让摄像机跟随无人机（可选）

        viewer.zoomTo(droneEntity);

        // 每隔 5 秒检测一次障碍物
        detectionIntervalId = setInterval(() => {
          const currentPosition = droneEntity.position.getValue(viewer.clock.currentTime);
          if (currentPosition) {
            // 获取地面高度（只取当前位置）
            const carto = Cesium.Cartographic.fromCartesian(currentPosition);
            const terrainHeightPromise = Cesium.sampleTerrainMostDetailed(
              viewer.terrainProvider,
              [carto]
            );
            terrainHeightPromise.then(result => {
              const terrainHeight = result[0].height;
              runRayDetection(currentPosition, terrainHeight);
            });
          }
        }, 5000 * 2);

      } catch (error) {
        console.error("初始化无人机飞行时出错:", error);
      }
    })();
    function clearRayEntities() {
      rayEntities.forEach(entity => {
        if (viewer.entities.contains(entity)) {
          viewer.entities.remove(entity);
        }
      });
      rayEntities = [];
    }

    function runRayDetection(dronePositionCartesian, terrainHeight) {
      // 清除旧射线
      console.log("检测前实体数量:", viewer.entities.values.length);
      clearRayEntities();
      console.log("检测后实体数量:", viewer.entities.values.length);

      const coneRays = generateSphericalRays(dronePositionCartesian, 30, 30);
      let collisionDetected = false;

      // 临时存储所有射线的碰撞信息
      const rayResults = [];

      // 第一步：先检测所有射线，收集碰撞信息
      coneRays.forEach((rayInfo, index) => {
        const ray = new Cesium.Ray(dronePositionCartesian, rayInfo.direction);

        const excludeEntities = [droneEntity];
        const hitPoint = viewer.scene.pickFromRay(ray, excludeEntities);

        if (hitPoint && hitPoint.position) {
          const cartographicHit = Cesium.Cartographic.fromCartesian(hitPoint.position);
          const distance = Cesium.Cartesian3.distance(dronePositionCartesian, hitPoint.position);
          const buildingHeight = Math.max(0, cartographicHit.height - terrainHeight);

          if (distance < 200) {
            rayResults.push({
              rayInfo: rayInfo,
              hitPoint: hitPoint,
              distance: distance,
              buildingHeight: buildingHeight
            });
            collisionDetected = true;
          }
        }
      });

      // 第二步：只有当有碰撞时才显示射线和碰撞点
      if (collisionDetected) {
        console.log(`✅ 检测到 ${rayResults.length} 个障碍物，显示相关射线`);

        const startTime = viewer.clock.currentTime.clone();
        const stopTime = Cesium.JulianDate.addSeconds(startTime, 3, new Cesium.JulianDate());

        if (rayResults.length > 0) {
          // 按距离从小到大排序
          rayResults.sort((a, b) => a.distance - b.distance);

          // 取最近的5个障碍物
          const closestResults = rayResults.slice(0, 5);

          closestResults.forEach((result, index) => {
            const { rayInfo, hitPoint, distance, buildingHeight } = result;

            // 显示射线
            const rayEntity = viewer.entities.add({
              availability: new Cesium.TimeIntervalCollection([new Cesium.TimeInterval({
                start: startTime,
                stop: stopTime
              })]),
              polyline: {
                positions: [
                  dronePositionCartesian,
                  Cesium.Cartesian3.add(
                    dronePositionCartesian,
                    Cesium.Cartesian3.multiplyByScalar(rayInfo.direction, 500, new Cesium.Cartesian3()),
                    new Cesium.Cartesian3()
                  )
                ],
                width: rayInfo.isCenterRay ? 6 : 4,
                material: rayInfo.isCenterRay
                  ? new Cesium.PolylineOutlineMaterialProperty({
                    color: Cesium.Color.RED,
                    outlineColor: Cesium.Color.BLACK,
                    outlineWidth: 1
                  })
                  : new Cesium.PolylineGlowMaterialProperty({
                    color: Cesium.Color.BLUE.withAlpha(0.7),
                    glowPower: 0.1
                  })
              }
            });
            rayEntities.push(rayEntity);

            // 显示碰撞点
            const hitEntity = viewer.entities.add({
              availability: new Cesium.TimeIntervalCollection([new Cesium.TimeInterval({
                start: startTime,
                stop: stopTime
              })]),
              position: hitPoint.position,
              point: {
                pixelSize: rayInfo.isCenterRay ? 30 : 20,
                color: distance < 100 ? Cesium.Color.RED :
                  distance < 200 ? Cesium.Color.ORANGE : Cesium.Color.YELLOW,
                outlineColor: Cesium.Color.WHITE,
                outlineWidth: 2
              },
              label: {
                text: `高度: ${buildingHeight.toFixed(1)}m\n距离: ${distance.toFixed(1)}m`,
                font: '12px sans-serif',
                fillColor: Cesium.Color.WHITE,
                outlineColor: Cesium.Color.BLACK,
                outlineWidth: 2,
                style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                pixelOffset: new Cesium.Cartesian2(0, -30)
              }
            });
            rayEntities.push(hitEntity);
          });

          // 添加统计信息
          const statsEntity = viewer.entities.add({
            availability: new Cesium.TimeIntervalCollection([new Cesium.TimeInterval({
              start: startTime,
              stop: stopTime
            })]),
            position: dronePositionCartesian,
            label: {
              text: `检测到 ${rayResults.length} 个障碍物\n显示最近 ${closestResults.length} 个`,
              font: '14px sans-serif',
              fillColor: Cesium.Color.CYAN,
              outlineColor: Cesium.Color.BLACK,
              outlineWidth: 2,
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              pixelOffset: new Cesium.Cartesian2(0, 30)
            }
          });
          rayEntities.push(statsEntity);
        }
        console.log("✅ 未检测到近距离障碍物，不显示射线");
      }
    }

    // 生成垂直向下的射线方向（局部坐标系）
    function getLocalDownDirection(position) {
      // 获取位置的局部东北天(ENU)坐标系
      const enuMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);

      // 从ENU矩阵中提取"下"方向（ENU中的Down是-Z轴）
      const downDirection = new Cesium.Cartesian3();
      Cesium.Matrix4.multiplyByPointAsVector(
        enuMatrix,
        new Cesium.Cartesian3(0, 0, -1),
        downDirection
      );

      Cesium.Cartesian3.normalize(downDirection, downDirection);
      return downDirection;
    }

    // 生成锥形分布的射线
    function generateConeRays(origin, rayCount = 12, coneAngle = 30) {
      const rays = [];

      // 获取局部坐标系的"下"方向
      const localDown = getLocalDownDirection(origin);

      // 获取局部坐标系的变换矩阵
      const enuMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);
      const inverseEnuMatrix = Cesium.Matrix4.inverse(enuMatrix, new Cesium.Matrix4());

      if (rayCount === 1) {
        // 只生成一个垂直向下的射线
        rays.push({
          direction: localDown,
          isCenterRay: true
        });
        return rays;
      }

      // 生成锥形射线
      for (let i = 0; i < rayCount; i++) {
        if (i === 0) {
          // 中心射线：垂直向下
          rays.push({
            direction: localDown,
            horizontalAngle: 0,
            verticalAngle: 0,
            isCenterRay: true
          });
        } else {
          // 锥形周围的射线
          const surroundingRays = rayCount - 1;
          const index = i - 1;

          const horizontalAngle = (index / surroundingRays) * 2 * Math.PI;
          const coneAngleRad = Cesium.Math.toRadians(coneAngle);

          // 在局部ENU坐标系中计算方向
          const x = Math.sin(coneAngleRad) * Math.cos(horizontalAngle); // 东向分量
          const y = Math.sin(coneAngleRad) * Math.sin(horizontalAngle); // 北向分量
          const z = -Math.cos(coneAngleRad); // 下向分量（负号表示向下）

          // 转换到世界坐标系
          const localDirection = new Cesium.Cartesian3(x, y, z);
          const worldDirection = new Cesium.Cartesian3();

          Cesium.Matrix4.multiplyByPointAsVector(enuMatrix, localDirection, worldDirection);
          Cesium.Cartesian3.normalize(worldDirection, worldDirection);

          rays.push({
            direction: worldDirection,
            horizontalAngle: Cesium.Math.toDegrees(horizontalAngle),
            verticalAngle: coneAngle,
            isCenterRay: false
          });
        }
      }

      return rays;
    }


    function generateSphericalRays(origin, latStepDegrees = 30, lonStepDegrees = 30) {
      const rays = [];

      // 获取局部坐标系ENU矩阵（东-北-天）
      const enuMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);

      // 纬度从 -90°（南极）到 +90°（北极）
      for (let lat = -90; lat <= 90; lat += latStepDegrees) {
        const latRad = Cesium.Math.toRadians(lat);

        // 经度从 0° 到 360°
        // 在两极时，只需要一个点即可（避免重复）
        const lonCount = (lat === -90 || lat === 90) ? 1 : Math.floor(360 / lonStepDegrees);

        for (let i = 0; i < lonCount; i++) {
          const lon = i * lonStepDegrees;
          const lonRad = Cesium.Math.toRadians(lon);

          // 球面坐标转换为局部 ENU 坐标 (x: East, y: North, z: Up)
          // 球面坐标定义：
          // x = cos(lat) * cos(lon)
          // y = cos(lat) * sin(lon)
          // z = sin(lat)
          const x = Math.cos(latRad) * Math.cos(lonRad);
          const y = Math.cos(latRad) * Math.sin(lonRad);
          const z = Math.sin(latRad);

          const localDirection = new Cesium.Cartesian3(x, y, z);

          // 转换为世界坐标系方向向量
          const worldDirection = new Cesium.Cartesian3();
          Cesium.Matrix4.multiplyByPointAsVector(enuMatrix, localDirection, worldDirection);
          Cesium.Cartesian3.normalize(worldDirection, worldDirection);

          rays.push({
            direction: worldDirection,
            latitude: lat,
            longitude: lon,
            isCenterRay: false
          });
        }
      }

      return rays;
    }


    function generateSixFixedRays(origin) {
      const rays = [];
      const enuMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);

      // ENU局部坐标系中的6个方向向量（单位向量）
      const localDirections = [
        new Cesium.Cartesian3(0, 0, 1),   // 上 (天)
        new Cesium.Cartesian3(0, 0, -1),  // 下 (地)
        new Cesium.Cartesian3(1, 0, 0),   // 东
        new Cesium.Cartesian3(0, 1, 0),   // 北
        new Cesium.Cartesian3(-1, 0, 0),  // 西
        new Cesium.Cartesian3(0, -1, 0),  // 南
      ];

      localDirections.forEach((localDir, index) => {
        const worldDir = new Cesium.Cartesian3();
        Cesium.Matrix4.multiplyByPointAsVector(enuMatrix, localDir, worldDir);
        Cesium.Cartesian3.normalize(worldDir, worldDir);
        rays.push({
          direction: worldDir,
          description: ['上', '下', '东', '北', '西', '南'][index],
          isCenterRay: false
        });
      });

      return rays;
    }

  </script>
</body>

</html>